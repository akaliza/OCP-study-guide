sub instanceof pai -> true

class HeavyAnimal { }
class Hippo extends HeavyAnimal { }
class Elephant extends HeavyAnimal { }


12: HeavyAnimal hippo = new Hippo();
13: boolean b1 = hippo instanceof Hippo; // true
14: boolean b2 = hippo instanceof HeavyAnimal; // true
15: boolean b3 = hippo instanceof Elephant; // false


30: Hippo anotherHippo = new Hippo();
31: boolean b5 = anotherHippo instanceof Elephant; // DOES NOT COMPILE

The compiler knows that there is no possible way for a Hippo
variable reference to be an Elephant, since Hippo doesn’t extend Elephant directly or
indirectly.



public interface Mother {}
class Hippo extends HeavyAnimal { }

This code compiles:
42: HeavyAnimal hippo = new Hippo();
43: boolean b6 = hippo instanceof Mother;

It so happens that Hippo does not implement Mother. The compiler allows the statement
because there could later be a class such as this:
class MotherHippo extends Hippo implements Mother { }




Hashcode 
- it can't use more variables than equals() method.
- If equals() returns false when called with two objects, calling hashCode() on each of
those objects does not have to return a different result.
- If equals() returns true when called with two objects, calling hashCode() on each of
those objects must return the same result.
- Within the same program, the result of hashCode() must not change. This means that
you shouldn’t include variables that change in figuring out the hash code.


ENUMS

public enum Season {
   WINTER, SPRING, SUMMER, FALL
}

for(Season season: Season.values()) {
   System.out.println(season.name() + " " + season.ordinal());
}

WINTER 0
SPRING 1
SUMMER 2
FALL 3


You can’t do is extend an enum.

Season summer = Season.SUMMER;
switch (summer) {
	case Season.WINTER: <<---NAO COMPILA DESTA FORMA
		System.out.println("Get out the sled!");
		break;
	case SUMMER: <<--- ASSIM COMPILA
		System.out.println("Time for the pool!");
		break;


apenas aceita construtores privados

somente chama o construtor no momento que carrega;

public enum OnlyOne {
ONCE (true);
private OnlyOne(boolean b) {
System. out .println("constructing");
}
public static void main(String[] args) {
OnlyOne firstCall = OnlyOne. ONCE ; // prints constructing
OnlyOne secondCall = OnlyOne. ONCE ; // doesn't print anything
} }


public enum Season3 {
WINTER {
public void printHours() { System.out.println("short hours"); }
}, SUMMER {
public void printHours() { System.out.println("long hours"); }
}, SPRING, FALL;
public void printHours() { System.out.println("default hours"); }
}

Inner classes 

Inner classes can have the same variable names as outer classes. There is a special way of
calling this to say which class you want to access:

1: public class A {
2: private int x = 10;
3: class B {
4: private int x = 20;
5: class C {
6: private int x = 30;
7: public void allTheX() {
8: System.out.println(x); // 30
9: System.out.println(this.x); // 30
10: System.out.println(B.this.x); // 20
11: System.out.println(A.this.x); // 10


cap2

default method and static in interface only can be public 


polymorphism: 
If you use a variable to refer to an object, then only the methods or variables that are
part of the variable’s reference type can be called without an explicit cast. For example, the
following snippets of code will not compile


1. The type of the object determines which properties exist within the object in memory.
2. The type of the reference to the object determines which methods and variables are
accessible to the Java program.

CAST:

Lemur lemur = new Lemur();
Primate primate = lemur;
Lemur lemur2 = primate; // DOES NOT COMPILE
Lemur lemur3 = (Lemur)primate;
System.out.println(lemur3.age);

1. Casting an object from a subclass to a superclass doesn’t require an explicit cast.
2. Casting an object from a superclass to a subclass requires an explicit cast.
3. The compiler will not allow casts to unrelated types.
4. Even when the code compiles without issue, an exception may be thrown at runtime if
the object being cast is not actually an instance of that class.

cap3

for methods: 
3: public static <T> void sink(T t) { }
4: public static <T> T identity(T t) { return t; }
5: public static T noGood(T t) { return t; } // DOES NOT COMPILE

call:
Box.<String>ship("package");
Box.<String[]>ship(args);


3: java.util.List numbers = new java.util.ArrayList();
4: numbers.add(5);
5: int result = numbers.get(0); // DOES NOT COMPILE

The good news is that unboxing fails with a compiler error rather than a runtime error.
On line 3, we create a raw list. On line 4, we try to add an int to the list. This works
because Java automatically autoboxes to an Integer. On line 5, we have a problem. Since
we aren’t using generics, Java doesn’t know that the list contains an Integer. It just knows
that we have an Object. And an Object can’t be unboxed into an int.


wildcard 	?
upper bound	? extends type
lower bound 	? super type



We can’t write List<Object> l = new ArrayList<String>(); because Java is trying to
protect us from a runtime exception. You might think this would mean that we can’t write
Object[] o = new String[0];. That isn’t the case. This code does compile:
Integer[] numbers = { new Integer(42)};
Object[] objects = numbers;
objects[0] = "forty two"; // throws ArrayStoreException
Although the code does compile, it throws an exception at runtime.


upper bounded:
ArrayList<Number> list = new ArrayList<Integer>(); // DOES NOT COMPILE
List<? extends Number> list = new ArrayList<Integer>();

<B extends A> B method3(List<B> list) {
return new B(); // DOES NOT COMPILE
}
method3() does not compile. <B extends A> says that you want to use B as a type
parameter just for this method and that it needs to extend the A class. Coincidentally, B
is also the name of a class. It isn’t a coincidence. It’s an evil trick. Within the scope of the
method, B can represent classes A, B, or C, because all extend the A class. Since B no longer
refers to the B class in the method, you can’t instantiate it.


<X> void method5(List<X super B> list) { // DOES NOT COMPILE
}
method5() does not compile because it tries to mix a method-specific type parameter
with a wildcard. A wildcard must have a ? in it.


[] List: A list is an ordered collection of elements that allows duplicate entries. Elements
in a list can be accessed by an int index.
[] Set: A set is a collection that does not allow duplicate entries.
[] Queue: A queue is a collection that orders its elements in a specific order for processing.
A typical queue processes its elements in a first-in, first-out order, but other orderings
are possible.
[] Map: A map is a collection that maps keys to values, with no duplicate keys allowed.
The elements in a map are key/value pairs.


boolean add(E element)

boolean remove(Object object)
boolean remove(int index) //overload
Since calling remove() with an int uses the index, an index that doesn’t
exist will throw an exception.

boolean isEmpty()

int size()

void clear()

boolean contains(Object object)
This method calls equals() on each element of the ArrayList

-----------------

>>List

ArrayList

LinkedList(implements both List and Queue)
The main benefits of a LinkedList are that you can access, add, and remove from the
beginning and end of the list in constant time.

Vector (is thread-safe)

Stack
is a data structure where you add and remove elements from the top of the stack. 
If you need a stack, use an ArrayDeque instead.


void add(E element)
void add(int index, E element)
E get(int index)
int indexOf(Object o) -1 	return the first matching index, -1 if not found 
int lastIndexOf(Object o)	return the last matching index, -1 if not found
void remove(int index)
E set(int index, E e)


Iterator iter = list.iterator();
while(iter.hasNext()) {
String string = (String) iter.next();
System.out.println(string);
}

or

Iterator<String> iter = list.iterator();
while(iter.hasNext()) {
String string = iter.next();
System.out.println(string);
}

-----------------


>>Using the Set Interface

HashSet
The main benefit is that adding elements and checking if an element is in the set both
have constant time. The tradeoff is that you lose the order in which you inserted the
elements.

TreeSet
stores its elements in a sorted tree structure. TreeSet implements a special interface called NavigableSet, which
lets you slice up the collection.


The NavigableSet Interface
Method 		Description
E lower(E e) 	Returns greatest element that is < e,  or null if no such element
E floor(E e) 	Returns greatest element that is <= e, or null if no such element
E ceiling(E e) 	Returns smallest element that is >= e, or null if no such element
E higher(E e) 	Returns smallest element that is > e,  or null if no such element

36: NavigableSet<Integer> set = new TreeSet<>();
37: for (int i = 1; i <= 20; i++) set.add(i);
38: System.out.println(set.lower(10)); // 9
39: System.out.println(set.floor(10)); // 10
40: System.out.println(set.ceiling(20)); // 20
41: System.out.println(set.higher(20)); // null


------------------------------------------------

>>Using the Queue Interface

