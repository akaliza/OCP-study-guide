sub instanceof pai -> true

class HeavyAnimal { }
class Hippo extends HeavyAnimal { }
class Elephant extends HeavyAnimal { }


12: HeavyAnimal hippo = new Hippo();
13: boolean b1 = hippo instanceof Hippo; // true
14: boolean b2 = hippo instanceof HeavyAnimal; // true
15: boolean b3 = hippo instanceof Elephant; // false


30: Hippo anotherHippo = new Hippo();
31: boolean b5 = anotherHippo instanceof Elephant; // DOES NOT COMPILE

The compiler knows that there is no possible way for a Hippo
variable reference to be an Elephant, since Hippo doesn’t extend Elephant directly or
indirectly.



public interface Mother {}
class Hippo extends HeavyAnimal { }

This code compiles:
42: HeavyAnimal hippo = new Hippo();
43: boolean b6 = hippo instanceof Mother;

It so happens that Hippo does not implement Mother. The compiler allows the statement
because there could later be a class such as this:
class MotherHippo extends Hippo implements Mother { }




Hashcode 
- it can't use more variables than equals() method.
- If equals() returns false when called with two objects, calling hashCode() on each of
those objects does not have to return a different result.
- If equals() returns true when called with two objects, calling hashCode() on each of
those objects must return the same result.
- Within the same program, the result of hashCode() must not change. This means that
you shouldn’t include variables that change in figuring out the hash code.


ENUMS

public enum Season {
   WINTER, SPRING, SUMMER, FALL
}

for(Season season: Season.values()) {
   System.out.println(season.name() + " " + season.ordinal());
}

WINTER 0
SPRING 1
SUMMER 2
FALL 3


You can’t do is extend an enum.

Season summer = Season.SUMMER;
switch (summer) {
	case Season.WINTER: <<---NAO COMPILA DESTA FORMA
		System.out.println("Get out the sled!");
		break;
	case SUMMER: <<--- ASSIM COMPILA
		System.out.println("Time for the pool!");
		break;


apenas aceita construtores privados

somente chama o construtor no momento que carrega;

public enum OnlyOne {
ONCE (true);
private OnlyOne(boolean b) {
System. out .println("constructing");
}
public static void main(String[] args) {
OnlyOne firstCall = OnlyOne. ONCE ; // prints constructing
OnlyOne secondCall = OnlyOne. ONCE ; // doesn't print anything
} }


public enum Season3 {
WINTER {
public void printHours() { System.out.println("short hours"); }
}, SUMMER {
public void printHours() { System.out.println("long hours"); }
}, SPRING, FALL;
public void printHours() { System.out.println("default hours"); }
}

Inner classes 

Inner classes can have the same variable names as outer classes. There is a special way of
calling this to say which class you want to access:

1: public class A {
2: private int x = 10;
3: class B {
4: private int x = 20;
5: class C {
6: private int x = 30;
7: public void allTheX() {
8: System.out.println(x); // 30
9: System.out.println(this.x); // 30
10: System.out.println(B.this.x); // 20
11: System.out.println(A.this.x); // 10


cap2

default method and static in interface only can be public 


polymorphism: 
If you use a variable to refer to an object, then only the methods or variables that are
part of the variable’s reference type can be called without an explicit cast. For example, the
following snippets of code will not compile


1. The type of the object determines which properties exist within the object in memory.
2. The type of the reference to the object determines which methods and variables are
accessible to the Java program.

CAST:

Lemur lemur = new Lemur();
Primate primate = lemur;
Lemur lemur2 = primate; // DOES NOT COMPILE
Lemur lemur3 = (Lemur)primate;
System.out.println(lemur3.age);

1. Casting an object from a subclass to a superclass doesn’t require an explicit cast.
2. Casting an object from a superclass to a subclass requires an explicit cast.
3. The compiler will not allow casts to unrelated types.
4. Even when the code compiles without issue, an exception may be thrown at runtime if
the object being cast is not actually an instance of that class.

cap3

for methods: 
3: public static <T> void sink(T t) { }
4: public static <T> T identity(T t) { return t; }
5: public static T noGood(T t) { return t; } // DOES NOT COMPILE

call:
Box.<String>ship("package");
Box.<String[]>ship(args);


3: java.util.List numbers = new java.util.ArrayList();
4: numbers.add(5);
5: int result = numbers.get(0); // DOES NOT COMPILE

The good news is that unboxing fails with a compiler error rather than a runtime error.
On line 3, we create a raw list. On line 4, we try to add an int to the list. This works
because Java automatically autoboxes to an Integer. On line 5, we have a problem. Since
we aren’t using generics, Java doesn’t know that the list contains an Integer. It just knows
that we have an Object. And an Object can’t be unboxed into an int.


wildcard 	?
upper bound	? extends type
lower bound 	? super type



We can’t write List<Object> l = new ArrayList<String>(); because Java is trying to
protect us from a runtime exception. You might think this would mean that we can’t write
Object[] o = new String[0];. That isn’t the case. This code does compile:
Integer[] numbers = { new Integer(42)};
Object[] objects = numbers;
objects[0] = "forty two"; // throws ArrayStoreException
Although the code does compile, it throws an exception at runtime.


upper bounded:
ArrayList<Number> list = new ArrayList<Integer>(); // DOES NOT COMPILE
List<? extends Number> list = new ArrayList<Integer>();

<B extends A> B method3(List<B> list) {
return new B(); // DOES NOT COMPILE
}
method3() does not compile. <B extends A> says that you want to use B as a type
parameter just for this method and that it needs to extend the A class. Coincidentally, B
is also the name of a class. It isn’t a coincidence. It’s an evil trick. Within the scope of the
method, B can represent classes A, B, or C, because all extend the A class. Since B no longer
refers to the B class in the method, you can’t instantiate it.


<X> void method5(List<X super B> list) { // DOES NOT COMPILE
}
method5() does not compile because it tries to mix a method-specific type parameter
with a wildcard. A wildcard must have a ? in it.


[] List: A list is an ordered collection of elements that allows duplicate entries. Elements
in a list can be accessed by an int index.
[] Set: A set is a collection that does not allow duplicate entries.
[] Queue: A queue is a collection that orders its elements in a specific order for processing.
A typical queue processes its elements in a first-in, first-out order, but other orderings
are possible.
[] Map: A map is a collection that maps keys to values, with no duplicate keys allowed.
The elements in a map are key/value pairs.


boolean add(E element)

boolean remove(Object object)
boolean remove(int index) //overload
Since calling remove() with an int uses the index, an index that doesn’t
exist will throw an exception.

boolean isEmpty()

int size()

void clear()

boolean contains(Object object)
This method calls equals() on each element of the ArrayList

-----------------

>>List

ArrayList

LinkedList(implements both List and Queue)
The main benefits of a LinkedList are that you can access, add, and remove from the
beginning and end of the list in constant time.

Vector (is thread-safe)

Stack
is a data structure where you add and remove elements from the top of the stack. 
If you need a stack, use an ArrayDeque instead.


void add(E element)
void add(int index, E element)
E get(int index)
int indexOf(Object o) -1 	return the first matching index, -1 if not found 
int lastIndexOf(Object o)	return the last matching index, -1 if not found
void remove(int index)
E set(int index, E e)


Iterator iter = list.iterator();
while(iter.hasNext()) {
String string = (String) iter.next();
System.out.println(string);
}

or

Iterator<String> iter = list.iterator();
while(iter.hasNext()) {
String string = iter.next();
System.out.println(string);
}

-----------------


>>Using the Set Interface

HashSet
The main benefit is that adding elements and checking if an element is in the set both
have constant time. The tradeoff is that you lose the order in which you inserted the
elements.

TreeSet
stores its elements in a sorted tree structure. TreeSet implements a special interface called NavigableSet, which
lets you slice up the collection.


The NavigableSet Interface
Method 		Description
E lower(E e) 	Returns greatest element that is < e,  or null if no such element
E floor(E e) 	Returns greatest element that is <= e, or null if no such element
E ceiling(E e) 	Returns smallest element that is >= e, or null if no such element
E higher(E e) 	Returns smallest element that is > e,  or null if no such element

36: NavigableSet<Integer> set = new TreeSet<>();
37: for (int i = 1; i <= 20; i++) set.add(i);
38: System.out.println(set.lower(10)); // 9
39: System.out.println(set.floor(10)); // 10
40: System.out.println(set.ceiling(20)); // 20
41: System.out.println(set.higher(20)); // null


------------------------------------------------

>>Using the Queue Interface

a queue is assumed to be FIFO (first-in, first-out).

LinkedList: 
The main benefit of a LinkedList is that it implements both the List and Queue interfaces. The tradeoff is that it isn’t as efficient as a “pure” queue.

ArrayDeque:
An ArrayDeque is a “pure” double-ended queue. The main benefit of an ArrayDeque is that it is more
efficient than a LinkedList.

ArrayDeque

boolean add(E e) 	Adds an element to the back of the queue and returns true or throws an exception

E element()             Returns next element or throws an exception if empty queue 

boolean offer(E e)	Adds an element to the back of the queue and returns whether successful

E remove()		Removes and returns next element or throws an exception if empty queue

void push(E e) 		Adds an element to the front of the queue

E poll() 		Removes and returns next element or returns null if empty queue

E peek() 		Returns next element or returns null if empty queue

E pop() 		Removes and returns next element or throws an exception if empty queue


12: Queue<Integer> queue = new ArrayDeque<>();
13: System.out.println(queue.offer(10)); // true   [10] 
14: System.out.println(queue.offer(4)); // true	   [10,4] 	
15: System.out.println(queue.peek()); // 10	   [10,4]
16: System.out.println(queue.poll()); // 10	   [4]
17: System.out.println(queue.poll()); // 4	   []	
18: System.out.println(queue.peek()); // null      []


LIFO (stack): 		  push/poll/peek
FIFO (single-endedqueue): offer/poll/peek

 
stack: 

12: ArrayDeque<Integer> stack = new ArrayDeque<>();
13: stack.push(10); 					[10]
14: stack.push(4);					[4,10]
15: System.out.println(stack.peek()); // 4
16: System.out.println(stack.poll()); // 4		[10]
17: System.out.println(stack.poll()); // 10		[]
18: System.out.println(stack.peek()); // null		[]



To review, a queue is like a line of people. You get on in the back and off
in the front. A stack is like a stack of plates. You put the plate on the top and take it off
the top. Since the stack is implemented using ArrayDeque, we refer to “top” and “front”
interchangeably.
A LinkedList works the exact same way as ArrayDeque, so we will skip showing the
code for that one.

------------------------------------------------------------------

>>>Map

HashMap

TreeMap - the keys are always in sorted order. 

A Hashtable - is like Vector in that it is really old and thread-safe and that you won’t be
expected to use it.



void clear() 			Removes all keys and values from the map.

boolean isEmpty() 		Returns whether the map is empty.

int size() 			Returns the number of entries (key/value pairs) in the map.

V get(Object key) 		Returns the value mapped by key or null if none is mapped.

V put(K key, V value) 		Adds or replaces key/value pair. Returns previous value or null.

V remove(Object key) 		Removes and returns value mapped to key. Returns null if none.

boolean containsKey(Object key) Returns whether key is in map.

boolean containsValue(Object)	Returns value is in map.

Set<K> keySet() 		Returns set of all keys.

Collection<V> values() 		Returns Collection of all values.


Map<String, String> map = new HashMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
System.out.print(key + ","); // koala,giraffe,lion,


Map<String, String> map = new TreeMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
System.out.print(key + ","); // giraffe,koala,lion,


System.out.println(map.contains("lion")); // DOES NOT COMPILE
System.out.println(map.containsKey("lion")); // true
System.out.println(map.containsValue("lion")); // false
System.out.println(map.size()); // 3



Type	Can contain		Elements	Has keys	Must add/remove
	duplicate elements?	ordered?	and values?	in specific order?


List 	Yes 			Yes (by index) 	No 		No
Map 	Yes (for values) 	No 		Yes 		No
Queue 	Yes 			Yes (retrieved 	No 		Yes
				    in defined order)

Set 	No 			No 		No 		No


TreeMap		—no null keys
Hashtable	—no null keys or values
TreeSet		—no null elements
ArrayDeque	—no null elements



String: As far as the exam is concerned, that means numbers sort before letters and uppercase letters sort before lowercase letters

java.lang
Interface Comparable<T>


public interface Comparable<T> {
   public int compareTo(T o);
}

public class Duck implements Comparable<Duck> {

  [...]
  public int compareTo(Duck d) {
     return name.compareTo(d.name); // call String's compareTo
  }
  [...]
}


[] The number zero is returned when the current object is equal to the argument to compareTo().
[] A number less than zero is returned when the current object is smaller than the argument
to compareTo().
[] A number greater than zero is returned when the current object is larger than the argument
to compareTo().

comparteTo expeted only objects, primitives types are note allowed. 

Remember that id – a.id sorts in ascending order and a.id – id sorts in
descending order.



java.util
Interface Comparator<T>



Comparator<Duck> byWeight = new Comparator<Duck>() {
public int compare(Duck d1, Duck d2) {
return d1.getWeight()—d2.getWeight();
}
};



public class MultiFieldComparator implements Comparator<Squirrel> {
   public int compare(Squirrel s1, Squirrel s2) {
      int result = s1.getSpecies().compareTo(s2.getSpecies());
      if (result != 0) return result;
      return s1.getWeight()—s2.getWeight();
   }
}

public class ChainingComparator implements Comparator<Squirrel> {
   public int compare(Squirrel s1, Squirrel s2) {
      Comparator<Squirrel> c = Comparator.comparing(s -> s.getSpecies());
      c = c.thenComparingInt(s -> s.getWeight());
      return c.compare(s1, s2);
   }
}

We grant you that it is the same number of lines. The second one is easier to read,
though. It describes what we are doing nicely. First we sort by species, and then
we sort by weight. We could have used method chaining to write this all on one
line.



1: import java.util.*;
2: public class SortRabbits {
3: static class Rabbit{ int id; }
4: public static void main(String[] args) {
5: List<Rabbit> rabbits = new ArrayList<>();
6: rabbits.add(new Rabbit());
7: Collections.sort(rabbits); // DOES NOT COMPILE
8: } }

Java knows that the Rabbit class is not Comparable. It knows sorting will fail, so it
doesn’t even let the code compile.


import java.util.*;
public class SortRabbits {
static class Rabbit{ int id; }
public static void main(String[] args) {
List<Rabbit> rabbits = new ArrayList<>();
rabbits.add(new Rabbit());
Comparator<Rabbit> c = (r1, r2) -> r1.id - r2.id;
Collections.sort(rabbits, c);
} }


sort() and binarySearch() allow you to pass in a Comparator object when you don’t want
to use the natural order. 

3: List<String> names = Arrays.asList("Fluffy", "Hoppy");
4: Comparator<String> c = Comparator.reverseOrder();
5: int index = Collections.binarySearch(names, "Hoppy", c);
6: System.out.println(index); //-1

You do need to know that the answer is not defined. Line 3 creates a list, [Fluffy,
Hoppy]. This list happens to be sorted in ascending order. Line 4 creates a Comparator that
reverses the natural order. Line 5 requests a binary search in descending order. Since the list
is in ascending order, we don’t meet the precondition for doing a search.




2: public class UseTreeSet {
3: static class Rabbit{ int id; }
4: public static void main(String[] args) {
5: Set<Duck> ducks = new TreeSet<>();
6: ducks.add(new Duck("Puddles"));
7: Set<Rabbit> rabbit = new TreeSet<>();
8: rabbit.add(new Rabbit()); // throws an exception
9: } }
Line 6 is fine. Duck does implement Comparable. TreeSet is able to sort it into the proper
position in the set. Line 8 is a problem. When TreeSet tries to sort it, Java discovers the
fact that Rabbit does not implement Comparable. Java throws an exception that looks like
this:
Exception in thread "main" java.lang.ClassCastException: comparing.Rabbit cannot
be cast to java.lang.Comparable


Just like searching and sorting, you can tell collections that require sorting that you wish
to use a specific Comparator, for example:

Set<Rabbit> rabbit = new TreeSet<>(new Comparator<Rabbit>() {
public int compare(Rabbit r1, Rabbit r2) {
return r1.id = r2.id;
}
});
rabbit.add(new Rabbit());


There are four formats for method references:
[] Static methods
[] Instance methods on a particular instance
[] Instance methods on an instance to be determined at runtime
[] Constructors


14: Consumer<List<Integer>> methodRef1 = Collections::sort;
15: Consumer<List<Integer>> lambda1 = l -> Collections.sort(l);

16: String str = "abc";
17: Predicate<String> methodRef2 = str::startsWith;
18: Predicate<String> lambda2 = s -> str.startsWith(s);

19: Predicate<String> methodRef3 = String::isEmpty;
20: Predicate<String> lambda3 = s -> s.isEmpty();


Line 19 says the method that we want to call is declared in String. It looks like a static
method, but it isn’t. Instead, Java knows that isEmpty is an instance method that does not
take any parameters. Java uses the parameter supplied at runtime as the instance on which
the method is called.

21: Supplier<ArrayList> methodRef4 = ArrayList::new;
22: Supplier<ArrayList> lambda4 = () -> new ArrayList();



-----------

boolean removeIf(Predicate<? super E> filter)

How would you replace line 8 with a method reference? Trick question—you can’t. Since
startsWith takes a parameter that isn’t s, it needs to be specified “the long way.”

The most important thing to remember about removeIf is that it is one of two methods that are on a collection and it takes a lambda parameter.

---
Another new method introduced on Lists is replaceAll.

void replaceAll(UnaryOperator<E> o)

List<Integer> list = Arrays.asList(1, 2, 3);
list.replaceAll(x -> x*2);
System.out.println(list); // [2, 4, 6]


----

putIfAbsent(), that you can call if you want to set a
value in the map, but this method skips it if the value is already set to a non-null value

Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", null);
favorites.putIfAbsent("Jenny", "Tram");
favorites.putIfAbsent("Sam", "Tram");
favorites.putIfAbsent("Tom", "Tram");
System.out.println(favorites); // {Tom=Tram, Jenny=Bus Tour, Sam=Tram}



merge --> NOT IN THE EXAM

11: BiFunction<String, String, String> mapper = (v1, v2)
12: -> v1.length() > v2.length() ? v1: v2;
13:
14: Map<String, String> favorites = new HashMap<>();
15: favorites.put("Jenny", "Bus Tour");
16: favorites.put("Tom", "Tram");
17:
18: String jenny = favorites.merge("Jenny", "Skyride", mapper);
19: String tom = favorites.merge("Tom", "Skyride", mapper);
20:
21: System.out.println(favorites); // {Tom=Skyride, Jenny=Bus Tour}
22: System.out.println(jenny); // Bus Tour
23: System.out.println(tom); // Skyride

The merge() method also has logic for what happens if nulls or missing keys are
involved. In this case, it doesn’t call the BiFunction at all, and it simply uses the new
value:

Notice that the mapping function isn’t called. If it were, we’d have a
NullPointerException. The mapping function is used only when there are two actual values
to decide between.


BiFunction<String, String, String> mapper = (v1, v2) -> null;
Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", "Bus Tour");
favorites.merge("Jenny", "Skyride", mapper);
favorites.merge("Sam", "Skyride", mapper);
System.out.println(favorites); // {Tom=Bus Tour, Sam=Skyride}

Tom was left alone since there was no merge() call for that key. Sam was added since
that key was not in the original list. Jenny was removed because the mapping function
returned null.

---

NOT IN THE EXAM 
In a nutshell, computeIfPresent() calls the BiFunction if the requested key is found.
For computeIfAbsent(), the functional interface runs only when the key isn’t present or
is null:

Map<String, Integer> counts = new HashMap<>();
counts.put("Jenny", 1);
counts.computeIfPresent("Jenny", (k, v) -> null);
counts.computeIfAbsent("Sam", k -> null);
System.out.println(counts); // {}




cap4

Lambda expressions can access static variables, instance variables, effectively final
method parameters, and effectively final local variables


Functional Interfaces 	# Parameters 	Return Type 	Single Abstract Method
=====================	============	===========	======================
Supplier<T> 		0 		T 		get
Consumer<T> 		1 (T) 		void 		accept
BiConsumer<T, U> 	2 (T, U) 	void 		accept
Predicate<T> 		1 (T) 		boolean 	test
BiPredicate<T, U> 	2 (T, U) 	boolean 	test
Function<T, R> 		1 (T) 		R 		apply
BiFunction<T, U, R> 	2 (T, U) 	R 		apply
UnaryOperator<T> 	1 (T) 		T 		apply
BinaryOperator<T> 	2 (T, T) 	T 		apply


@FunctionalInterface public class Supplier<T> {
   public T get();
}



@FunctionalInterface public class Consumer<T> {
void accept(T t);
}
@FunctionalInterface public class BiConsumer<T, U> {
void accept(T t, U u);
}



@FunctionalInterface public class Predicate<T> {
boolean test(T t);
}
@FunctionalInterface public class BiPredicate<T, U> {
boolean test(T t, U u);
}



@FunctionalInterface public class Function<T, R> {
R apply(T t);
}
@FunctionalInterface public class BiFunction<T, U, R> {
R apply(T t, U u);
}



@FunctionalInterface public class UnaryOperator<T>  extends Function<T, T> { }
@FunctionalInterface public class BinaryOperator<T> extends BiFunction<T, T, T> { }

This means that method signatures look like this:

T apply(T t);
T apply(T t1, T t2);


-----------

Method 			When Optional Is Empty 				When Optional Contains a Value
======================= ===========================================	==============================
get() 			Throws an exception 				Returns value
ifPresent(Consumer c) 	Does nothing 					Calls Consumer c with value
isPresent() 		Returns false 					Returns true
orElse(T other) 	Returns other parameter 			Returns value
orElseGet(Supplier s) 	Returns result of calling Supplier 		Returns value
orElseThrow(Supplier s) Throws exception createdby calling Supplier 	Returns value



10: public static Optional<Double> average(int… scores) {
11: if (scores.length == 0) return Optional.empty();
12: int sum = 0;
13: for (int score: scores) sum += score;
14: return Optional.of((double) sum / scores.length);
15: }


20: Optional<Double> opt = average(90, 100);
21: if (opt.isPresent())
22: System.out.println(opt.get()); // 95.0


26: Optional<Double> opt = average();
27: System.out.println(opt.get()); // bad
We’d get an exception since there is no value inside the Optional:
java.util.NoSuchElementException: No value present


Optional o = (value== null) ? Optional.empty(): Optional.of(value);

Java provides a factory method to do the same thing:
Optional o = Optional.ofNullable(value);


Optional<Double> opt = average(90, 100);
opt.ifPresent(System.out::println);


30: Optional<Double> opt = average();
31: System.out.println(opt.orElse(Double.NaN));
32: System.out.println(opt.orElseGet(() -> Math.random()));
33: System.out.println(opt.orElseThrow(() -> new IllegalStateException()));

NaN
0.49775932295380165
Exception in thread "main" java.lang.IllegalStateException
at optional.Average.lambda$3(Average.java:56)
at optional.Average$$Lambda$5/455659002.get(Unknown Source)
at java.util.Optional.orElseThrow(Optional.java:290)


System.out.println(opt.orElseGet(
() -> new IllegalStateException())); // DOES NOT COMPILE

opt is an Optional<Double>. This means the Supplier must return a Double. Since this
supplier returns an exception, the type does not match.

-------------------------------------------------------------------


1: Stream<String> empty = Stream.empty(); // count = 0
2: Stream<Integer> singleElement = Stream.of(1); // count = 1
3: Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 2 //varargs

4: List<String> list = Arrays.asList("a", "b", "c");
5: Stream<String> fromList = list.stream();
6: Stream<String> fromListParallel = list.parallelStream();


7: Stream<Double> randoms = Stream.generate(Math::random);
8: Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2);

If you call randoms.forEach(System.out::println) , the program will
print random numbers until you kill it.


iterate() takes a seed or starting value as the fi rst
parameter. This is the fi rst element that will be part of the stream. The other parameter is a
lambda expression that gets passed the previous value and generates the next value. As with
the random numbers example, it will keep on producing odd numbers as long as you need
them.

------------------
Terminal Operations

Method 			What Happens for Infinite Streams 	Return Value 	Reduction
=================	===================================	=============	=========
allMatch()		Sometimes terminates 			boolean 	No
/anyMatch()
/noneMatch()
 
collect() 		Does not terminate 			Varies 		Yes

count() 		Does not terminate 			long 		Yes

findAny()		Terminates 				Optional<T> 	No
/findFirst()

forEach() 		Does not terminate 			void 		No

min()/max() 		Does not terminate 			Optional<T> 	Yes

reduce() 		Does not terminate 			Varies 		Yes




long count()

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count()); // 3

--

Optional<T> min(<? super T> comparator)
Optional<T> max(<? super T> comparator)

Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length()—s2.length());
min.ifPresent(System.out::println); // ape

Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false

Since the stream is empty, the comparator is never called and no value is present in the
Optional.


--

Optional<T> findAny()
Optional<T> findFirst()

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");
s.findAny().ifPresent(System.out::println); // monkey
infinite.findAny().ifPresent(System.out::println); // chimp

If the stream is empty, they return an empty Optional.

----

boolean anyMatch(Predicate <? super T> predicate)
boolean allMatch(Predicate <? super T> predicate)
boolean noneMatch(Predicate <? super T> predicate)

List<String> list = Arrays.asList("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));
System.out.println(list.stream().anyMatch(pred)); // true
System.out.println(list.stream().allMatch(pred)); // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred)); // true

On the infinite list, one match is found, so the call terminates. If we called noneMatch() or allMatch() ,
they would run until we killed the program.


Remember that allMatch() , anyMatch() , and noneMatch() return a boolean. By contrast, the find methods return an Optional because they return an element of the stream.


-----------

void forEach(Consumer<? super T> action)

Notice that you can’t use a traditional for loop on a stream:
Stream s = Stream.of(1);
for (Integer i: s) {} // DOES NOT COMPILE

--

reduce()

T reduce(T identity, BinaryOperator<T> accumulator)
Optional<T> reduce(BinaryOperator<T> accumulator)
<U> U reduce(U identity, BiFunction<U,? super T,U> accumulator,
BinaryOperator<U> combiner)

Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", (s, c) -> s + c);
System.out.println(word); // wolf

Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", String::concat);
System.out.println(word); // wolf

Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, (a, b) -> a*b));

[] If the stream is empty, an empty Optional is returned.
[] If the stream has one element, it is returned.
[] If the stream has multiple elements, the accumulator is applied to combine them.


BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> empty = Stream.empty();
Stream<Integer> oneElement = Stream.of(3);
Stream<Integer> threeElements = Stream.of(3, 5, 6);
empty.reduce(op).ifPresent(System.out::print); // no output
oneElement.reduce(op).ifPresent(System.out::print); // 3
threeElements.reduce(op).ifPresent(System.out::print); // 90

The third method signature is used when we are processing collections in parallel. It
allows Java to create intermediate reductions and then combine them at the end. In our
example, it looks similar. While we aren’t actually using a parallel stream here, Java
assumes that a stream might be parallel. This is helpful because it lets us switch to a parallel
stream easily in the future:



BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, op, op)); // 90

----

collect()

<R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator,
BiConsumer<R, R> combiner)
<R,A> R collect(Collector<? super T, A,R> collector)


Stream<String> stream = Stream.of("w", "o", "l", "f");
StringBuilder word = stream.collect(StringBuilder::new,
StringBuilder::append, StringBuilder:append)

[] The first parameter is a Supplier that creates the object that will store the results as we
collect data. Remember that a Supplier doesn’t take any parameters and returns a value.
In this case, it constructs a new StringBuilder.
[] The second parameter is a BiConsumer, which takes two parameters and doesn’t return
anything. It is responsible for adding one more element to the data collection. In this example,
it appends the next String to the StringBuilder.
[] The final parameter is another BiConsumer. It is responsible for taking two data collections
and merging them. This is useful when we are processing in parallel. Two smaller
collections are formed and then merged into one. This would work with StringBuilder
only if we didn’t care about the order of the letters. In this case, the accumulator and combiner
have similar logic.


Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(TreeSet::new, TreeSet::add,
TreeSet::addAll);
System.out.println(set); // [f, l, o, w]

The collector has three parts as before. The supplier creates an empty TreeSet. The
accumulator adds a single String from the Stream to the TreeSet. The combiner adds all
of the elements of one TreeSet to another in case the operations were done in parallel and
need to be merged.



Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]

If we didn’t need the set to be sorted, we could make the code even shorter:
Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
-----------------------------------------------------------

Intermediate Operations


filter()

Stream<T> filter(Predicate<? super T> predicate)

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.filter(x -> x.startsWith("m")).forEach(System.out::print); // monkey


---

distinct()

Stream<T> distinct()

Stream<String> s = Stream.of("duck", "duck", "duck", "goose");
s.distinct().forEach(System.out::print); // duckgoose

---

limit() and skip()

Stream<T> limit(int maxSize)
Stream<T> skip(int n)

Stream<Integer> s = Stream.iterate(1, n -> n + 1);
s.skip(5).limit(2).forEach(System.out::print); // 67

---

map()

<R> Stream<R> map(Function<? super T, ? extends R> mapper)

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.map(String::length).forEach(System.out::print); // 676

--------
flatMap()

<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)

List<String> zero = Arrays.asList();
List<String> one = Arrays.asList("Bonobo");
List<String> two = Arrays.asList("Mama Gorilla", "Baby Gorilla");
Stream<List<String>> animals = Stream.of(zero, one, two);
animals.flatMap(l -> l.stream()).forEach(System.out::println);

Here’s the output:
Bonobo
Mama Gorilla
Baby Gorilla

---------
sorted()

Stream<T> sorted()
Stream<T> sorted(Comparator<? super T> comparator)

Stream<String> s = Stream.of("brown-", "bear-");
s.sorted().forEach(System.out::print); // bear-brown-

Stream<String> s = Stream.of("brown bear-", "grizzly-");
s.sorted(Comparator.reverseOrder())
.forEach(System.out::print); // grizzly-brown bear-


s.sorted(Comparator::reverseOrder); // DOES NOT COMPILE

Comparator is a functional interface.
This means that we can use method references or lambdas to implement it. The
Comparator interface implements one method that takes two String parameters and
returns an int . However, Comparator::reverseOrder doesn’t do that. It is a reference
to a function that takes zero parameters and returns a Comparator . This is not compatible
with the interface. This means that we have to use a method and not a method
reference. We bring this up to remind you that you really do need to know method references
well.


----

peek()

Stream<T> peek(Consumer<? super T> action)

Stream<String> stream = Stream.of("black bear", "brown bear", "grizzly");
long count = stream.filter(s -> s.startsWith("g"))
.peek(System.out::println).count(); // grizzly
System.out.println(count); // 1

When working with a Queue , peek() looks only at the first element. In a
stream, peek() looks at each element that goes through that part of the
stream pipeline. It’s like having a worker take notes on how a particular
step of the process is doing.

------------

List<String> list = Arrays.asList("Toby", "Anna", "Leroy", "Alex");
list.stream().filter(n -> n.length() == 4).sorted()
.limit(2).forEach(System.out::println);


-----------------------

working with primitives

Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.reduce(0, (s, n) -> s + n));

There is another way of doing that:

Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.mapToInt(x -> x).sum());

This time, we converted our Stream<Integer> to an IntStream and asked the IntStream
to calculate the sum for us. The primitive streams know how to perform certain common
operations automatically.


IntStream intStream = IntStream.of(1, 2, 3);
OptionalDouble avg = intStream.average();
System.out.println(avg.getAsDouble());

[] IntStream: Used for the primitive types int, short, byte, and char
[] LongStream: Used for the primitive type long
[] DoubleStream: Used for the primitive types double and float


DoubleStream empty = DoubleStream. empty ();


DoubleStream random = DoubleStream. generate (Math::random);
DoubleStream fractions = DoubleStream. iterate (.5, d -> d / 2);
random.limit(3).forEach(System.out::println);
System.out.println();
fractions.limit(3).forEach(System.out::println);


IntStream range = IntStream.range(1, 6);
range.forEach(System.out::println); //1-5

IntStream rangeClosed = IntStream.rangeClosed(1, 5);
rangeClosed.forEach(System.out::println); //1-5



Source Stream	To Create	To Create	To Create	To Create
Class		Stream		DoubleStream	IntStream	LongStream
=============	==============	===============	===============	================
Stream		map		mapToDouble	mapToInt	mapToLong 
DoubleStream	mapToObj	map		mapToInt	mapToLong
IntStream	mapToObj	mapToDouble	map		mapToLong
LongStream	mapToObj	mapTODouble	mapToInt	map



Stream<String> objStream = Stream.of("penguin", "fish");
IntStream intStream = objStream.mapToInt(s -> s.length());




Source Stream	To Create	To Create		To Create		To Create
Class		Stream		DoubleStream		IntStream		LongStream
=============	==============	===============		===============		================
Stream		Function	ToDoubleFunction	ToIntFunction		ToLongFunction
DoubleStream	DoubleFunction	DoubleUnaryOperator	DoubleToIntFunction	DoubleToLongFunction
IntStream	IntFunction	IntToDoubleFunction	IntUnaryOperator	IntToLongFunction
LongStream	LongFunction	LongToDoubleFunction	LongToIntFunction	LongUnaryOperator


-----------------

IntStream stream = IntStream.rangeClosed(1,10);
OptionalDouble optional = stream.average();


optional.ifPresent(System.out::println);
System.out.println(optional.getAsDouble());
System.out.println(optional.orElseGet(() -> Double.NaN));


orElseGet() takes a DoubleSupplier instead of a Supplier.


				OptionalDouble 	OptionalInt 	OptionalLong
==============================================================================
Getting as a primitive		getAsDouble()	getAsInt()	getAsLong()
orElseGet() parameter type	DoubleSupplier	IntSupplier	LongSupplier
Return type of max()		OptionalDouble	OptionalInt	OptionalLong
Return type of sum()		double		int		long
Return type of avg()		OptionalDouble	OptionalDouble	OptionalDouble



5: LongStream longs = LongStream.of(5, 10);
6: long sum = longs.sum();
7: System.out.println(sum); // 15
8: DoubleStream doubles = DoubleStream.generate(() -> Math.PI);
9: OptionalDouble min = doubles.min(); // runs infinitely

---------------------------

Summarizing Statistics

private static int max(IntStream ints) {
   OptionalInt optional = ints.max();
   return optional.orElseThrow(RuntimeException::new);
}


We
can’t run two terminal operations against the same stream. Luckily, this is a common problem
and the primitive streams solve it for us with summary statistics. Statistic is just a big
word for a number that was calculated from data:

private static int range(IntStream ints) {
   IntSummaryStatistics stats = ints.summaryStatistics();
   if (stats.getCount() == 0) throw new RuntimeException();
   return stats.getMax()—stats.getMin();
}

-----------------------------


Functional Interfaces for boolean

boolean getAsBoolean()

12: BooleanSupplier b1 = () -> true;
13: BooleanSupplier b2 = () -> Math.random() > .5;
14: System.out.println(b1.getAsBoolean());
15: System.out.println(b2.getAsBoolean());

------------------------------

Functional Interfaces for double, int, and long


Functional Interfaces	# Parameters		Return Type	Single Abstract Method
======================	====================	=============	=====================
DoubleSupplier		0			double		getAsDouble
IntSupplier					int		getAsInt
LongSupplier					long		getAsLong

DoubleConsumer		1(double)		void		accept
IntConsumer		1(int)	
LongConsumer		1(long)

DoublePredicate		1(double)		boolean		test
IntPredicate		1(int)
LongPredicate		1(long)

DoubleFunction<R>	1(double)		R		apply
IntFunction<R>		1(int)
LongFunction<R>		1(long)

DoubleUnaryOperator	1(double)		double		applyAsDouble
IntUnaryOperator	1(int)			int		applyAsInt
LongUnaryOperator	1(long)			long		applyAsLong

DoubleBinaryOperator	2(double, double)	double		applyAsDouble	
IntBinaryOperator	2(int, int)		int		applyAsInt
LongBinaryOperator	2(long,long)		long		applyAsLong



There are a few things to notice that are different between Table 4.1 and Table 4.9:

[] Generics are gone from some of the interfaces, since the type name tells us what primitive
type is involved. In other cases, such as IntFunction, only the return type generic is needed.	

[] The single abstract method is often, but not always, renamed to reflect the primitive
type involved.

[] BiConsumer, BiPredicate, and BiFunction are not in Table 4.9. The API designers
stuck to the most common operations. For primitives, the functions with two different
type parameters just aren’t used often.

TABELA 4.10...Verificar se necessario


===================================

Working with Advanced Stream
Pipeline Concepts


Linking Streams to the Underlying Data

25: List<String> cats = new ArrayList<>();
26: cats.add("Annie");
27: cats.add("Ripley");
28: Stream<String> stream = cats.stream();
29: cats.add("KC");
30: System.out.println(stream.count()); //3


Remember that streams are lazily evaluated. This
means that the stream isn’t actually created on line 28. An object is created that knows
where to look for the data when it is needed. On line 29, the List gets a new element. On
line 30, the stream pipeline actually runs.


Chaining Optionals

private static void threeDigit(Optional<Integer> optional) {
if (optional.isPresent()) { // outer if
Integer num = optional.get();
String string = "" + num;
if (string.length() == 3) // inner if
System.out.println(string);
} }

private static void threeDigit(Optional<Integer> optional) {
optional.map(n -> "" + n) // part 1
.filter(s -> s.length() == 3) // part 2
.ifPresent(System.out::println); // part 3
}

Now suppose that we wanted to get an Optional<Integer> representing the length of
the String contained in another Optional. Easy enough:
Optional<Integer> result = optional.map(String::length);


What if we had a helper method that did the logic of calculating something for us and it
had the signature static Optional<Integer> calculator(String s)? Using map doesn’t
work:

Optional<Integer> result = optional.map(ChainingOptionals::calculator); // DOES NOT COMPILE

The problem is that calculator returns Optional<Integer>. The map() method adds
another Optional, giving us Optional<Optional<Integer>>. Well, that’s no good. The
solution is to call flatMap() instead:

Optional<Integer> result = optional.flatMap(ChainingOptionals::calculator);

This one works because flatMap removes the unnecessary layer. In other words, it flattens
the result. Chaining calls to flatMap() is useful when you want to transform one
Optional type to another

------------------------------

Collecting Results


Table 4 .11 - verificar tabela 4.11


Collecting Using Basic Collectors

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
String result = ohMy.collect(Collectors.joining(", "));
System.out.println(result); // lions, tigers, bears

It is very important to pass the Collector to the collect method. It exists to help collect
elements. A Collector doesn’t do anything on its own.
Let’s try another one. What is the average length of the three animal names?

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Double result = ohMy.collect(Collectors.averagingInt(String::length));
System.out.println(result); // 5.333333333333333


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeSet<String> result = ohMy.filter(s -> s.startsWith("t")
.collect(Collectors.toCollection(TreeSet::new));
System.out.println(result); // [tigers]


-----------------------

Collecting into Maps

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<String, Integer> map = ohMy.collect(
Collectors.toMap(s -> s, String::length));
System.out.println(map); // {lions=5, bears=5, tigers=6}


Returning the same value passed into a lambda is a common operation, so Java provides
a method for it. You can rewrite s -> s as Function.identity(). It is not shorter and may
or may not be clearer, so use your judgment on whether to use it.

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, String> map = ohMy.collect(Collectors.toMap(String::length, k -> k)); // BAD

Running this gives an exception similar to the following:
Exception in thread "main" java.lang.IllegalStateException: Duplicate key lions
at java.util.stream.Collectors.lambda$throwingMerger$114(Collectors.java:133)
at java.util.stream.Collectors$$Lambda$3/1044036744.apply(Unknown Source)

What’s wrong? Two of the animal names are the same length.



Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, String> map = ohMy.collect(Collectors.toMap(
String::length, k -> k, (s1, s2) -> s1 + "," + s2));
System.out.println(map); // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class. java.util.HashMap


It so happens that the Map returned is a HashMap. This behavior is not guaranteed.
Suppose that we want to mandate that the code return a TreeMap instead. No problem. We
would just add a constructor reference as a parameter:

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, String> map = ohMy.collect(Collectors.toMap(
String::length, k -> k, (s1, s2) -> s1 + "," + s2, TreeMap::new));
System.out.println(map); // // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class. java.util.TreeMap

---------------------------

Collecting Using Grouping, Partitioning, and Mapping

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, List<String>> map = ohMy.collect(
Collectors.groupingBy(String::length));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Set<String>> map = ohMy.collect(
Collectors.groupingBy(String::length, Collectors.toSet()));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, Set<String>> map = ohMy.collect(
Collectors.groupingBy(String::length, TreeMap::new, Collectors.toSet()));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, List<String>> map = ohMy.collect(
Collectors.groupingBy(String::length, TreeMap::new, Collectors.toList()));
System.out.println(map);


Partitioning is a special case of grouping. With partitioning, there are only two possible
groups—true and false. Partitioning is like splitting a list into two parts.

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, List<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 5));
System.out.println(map); // {false=[tigers], true=[lions, bears]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, List<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 7));
System.out.println(map); // {false=[], true=[lions, tigers, bears]}


Notice that there are still two keys in the map—one for each boolean value. It so happens
that one of the values is an empty list, but it is still there. As with groupingBy(), we
can change the type of List to something else:

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, Set<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 7, Collectors.toSet()));
System.out.println(map);// {false=[], true=[lions, tigers, bears]}

Unlike groupingBy(), we cannot change the type of Map that gets returned.

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Long> map = ohMy.collect(Collectors.groupingBy(
String::length, Collectors.counting()));
System.out.println(map); // {5=2, 6=1}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Optional<Character>> map = ohMy.collect(
Collectors.groupingBy(
String::length,
Collectors.mapping(s -> s.charAt(0),
Collectors.minBy(Comparator.naturalOrder()))));
System.out.println(map); // {5=Optional[b], 6=Optional[t]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Optional<Character>> map = ohMy.collect(
groupingBy(
String::length,
mapping(s -> s.charAt(0),
minBy(Comparator.naturalOrder()))));
System.out.println(map); // {5=Optional[b], 6=Optional[t]}




Cap5
LocalDate Contains just a date—no time and no time zone.
LocalTime Contains just a time—no date and no time zone
LocalDateTime Contains both a date and time but no time zone.
ZonedDateTime Contains a date, time, and time zone.


System.out.println(LocalDate.now());
System.out.println(LocalTime.now());
System.out.println(LocalDateTime.now());
System.out.println(ZonedDateTime.now());


2015–05–25
09:13:07.768
2015–05–25T09:13:07.768
2015–05–25T09:13:07.769–04:00[America/New_York]


Greenwich Mean Time(GMT) is a time zone in Europe that is used as time zone zero when
discussing offsets.
Coordinated Universal Time(UTC) uses the same time zone zero as GMT.

2015–06–20T07:50+02:00[Europe/Paris] // GMT 2015–06–20 5:50
2015–06–20T06:50+05:30[Asia/Kolkata] // GMT 2015–06–20 1:20

2015–06–20T07:50 GMT-04:00 // GMT 2015–06–20 11:50
2015–06–20T04:50 GMT-07:00 // GMT 2015–06–20 11:50

2015–06–20T07:50–07:00[US/Pacific]   = 2015–06–20T14:50 
2015–06–20T07:50+05:30[Asia/Kolkata] = 2015–06–20T2:20


public static LocalDate of(int year, int month, int dayOfMonth)
public static LocalDate of(int year, Month month, int dayOfMonth)

public static LocalTime of(int hour, int minute)
public static LocalTime of(int hour, int minute, int second)
public static LocalTime of(int hour, int minute, int second, int nanos)


public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanos)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanos)
public static LocalDateTime of(LocalDate date, LocalTime time)


ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime zoned1 = ZonedDateTime.of(2015, 1, 20, 6, 15, 30, 200, zone);
ZonedDateTime zoned2 = ZonedDateTime.of(date1, time1, zone);
ZonedDateTime zoned3 = ZonedDateTime.of(dateTime1, zone);

public static ZonedDateTime of(int year, int month,int dayOfMonth, int hour, 
			       int minute, int second, int nanos, ZoneId zone)
public static ZonedDateTime of(LocalDate date, LocalTime time, ZoneId zone)
public static ZonedDateTime of(LocalDateTime dateTime, ZoneId zone)

Notice that there isn’t an option to pass in the Month enum. This seems like an oversight
from the API creators and something that will be fixed in future versions of Java.


ZoneId.getAvailableZoneIds().stream()
	.filter(z -> z.contains("US") || z.contains("America"))
	.sorted().forEach(System.out::println);


LocalDate.of(2015, Month.JANUARY, 32) // throws DateTimeException


12: LocalDate date = LocalDate.of(2014, Month.JANUARY, 20);
13: System.out.println(date); // 2014–01–20
14: date = date.plusDays(2);
15: System.out.println(date); // 2014–01–22
16: date = date.plusWeeks(1);
17: System.out.println(date); // 2014–01–29
18: date = date.plusMonths(1);
19: System.out.println(date); // 2014–02–28
20: date = date.plusYears(5);
21: System.out.println(date); // 2019–02–28

February 29 exists only in a leap year. Leap years are years that are a multiple
of 4 or 400 but not other multiples of 100. For example, 2000 and 2016
are leap years, but 2100 is not.


Period annually = Period.ofYears(1); // every 1 year
Period quarterly = Period.ofMonths(3); // every 3 months
Period everyThreeWeeks = Period.ofWeeks(3); // every 3 weeks
Period everyOtherDay = Period.ofDays(2); // every 2 days
Period everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days


Period wrong = Period.ofYears(1).ofWeeks(1); // every week


System.out.println(Period.of(0, 20, 47));//P20M47D
System.out.println(Period.ofWeeks(3)); //P21D

--------------------------

Working with Durations
For Duration, you can specify the number of days, hours, minutes, seconds, or nanoseconds

Remember that a Period is output beginning with a P. Duration is output beginning with PT.

Duration daily = Duration.ofDays(1); // PT24H
Duration hourly = Duration.ofHours(1); // PT1H
Duration everyMinute = Duration.ofMinutes(1); // PT1M
Duration everyTenSeconds = Duration.ofSeconds(10); // PT10S
Duration everyMilli = Duration.ofMillis(1); // PT0.001S
Duration everyNano = Duration.ofNanos(1); // PT0.000000001S

Duration includes another more generic factory method. It takes a number and a
TemporalUnit. The idea is, say, something like “5 seconds.” However, TemporalUnit is an
interface. At the moment, there is only one implementation named ChronoUnit.
The previous example could be rewritten as this:

Duration daily = Duration.of(1, ChronoUnit.DAYS);
Duration hourly = Duration.of(1, ChronoUnit.HOURS);
Duration everyMinute = Duration.of(1, ChronoUnit.MINUTES);
Duration everyTenSeconds = Duration.of(10, ChronoUnit.SECONDS);
Duration everyMilli = Duration.of(1, ChronoUnit.MILLIS);
Duration everyNano = Duration.of(1, ChronoUnit.NANOS);

ChronoUnit also includes some convenient units such as ChronoUnit.HALF_DAYS to represent
12 hours.


LocalTime one = LocalTime.of(5, 15);
LocalTime two = LocalTime.of(6, 30);
LocalDate date = LocalDate.of(2016, 1, 20);
System.out.println(ChronoUnit.HOURS.between(one, two)); // 1
System.out.println(ChronoUnit.MINUTES.between(one, two)); // 75
System.out.println(ChronoUnit.MINUTES.between(one, date)); // DateTimeException


7: LocalDate date = LocalDate.of(2015, 1, 20);
8: LocalTime time = LocalTime.of(6, 15);
9: LocalDateTime dateTime = LocalDateTime.of(date, time);
10: Duration duration = Duration.ofHours(6);
11: System.out.println(dateTime.plus(duration)); // 2015–01–20T12:15
12: System.out.println(time.plus(duration)); // 12:15
13: System.out.println(date.plus(duration)); // UnsupportedTemporalException


7: LocalDate date = LocalDate.of(2015, 1, 20);
8: LocalTime time = LocalTime.of(6, 15);
9: LocalDateTime dateTime = LocalDateTime.of(date, time);
10: Duration duration = Duration.ofHours(23);
11: System.out.println(dateTime.plus(duration)); // 2015–01–21T05:15
12: System.out.println(time.plus(duration)); // 05:15          
13: System.out.println(date.plus(duration)); // UnsupportedTemporalException


LocalDate date = LocalDate.of(2015, 5, 25);
Period period = Period.ofDays(1);
Duration days = Duration.ofDays(1);
System.out.println(date.plus(period)); // 2015–05–26
System.out.println(date.plus(days)); // Unsupported unit: Seconds


			Can Use with Period? 	Can Use with Duration?
LocalDate 		Yes 			No
LocalDateTime 		Yes 			Yes
LocalTime 		No 			Yes
ZonedDateTime 		Yes 			Yes



---------------------------------


Working with Instants

Instant now = Instant.now();
// do something time consuming
Instant later = Instant.now();

Duration duration = Duration.between(now, later);
System.out.println(duration.toMillis());


LocalDate date = LocalDate.of(2015, 5, 25);
LocalTime time = LocalTime.of(11, 55, 00);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime zonedDateTime = ZonedDateTime.of(date, time, zone);
Instant instant = zonedDateTime.toInstant(); // 2015–05–25T15:55:00Z
System.out.println(zonedDateTime); // 2015–05–25T11:55–04:00[US/Eastern]
System.out.println(instant); // 2015–05–25T15:55:00Z

You cannot convert a LocalDateTime to an Instant. Remember that an Instant is a
point in time. A LocalDateTime does not contain a time zone, and it is therefore not universally
recognized around the world as the same moment in time.


If you have the number of seconds since 1970, you can also create an Instant that way:

Instant instant = Instant.ofEpochSecond(epochSeconds);
System.out.println(instant); // 2015–05–25T15:55:00Z



Instant nextDay = instant.plus(1, ChronoUnit.DAYS);
System.out.println(nextDay); // 2015–05–26T15:55:00Z
Instant nextHour = instant.plus(1, ChronoUnit.HOURS);
System.out.println(nextHour); // 2015–05–25T16:55:00Z
Instant nextWeek = instant.plus(1, ChronoUnit.WEEKS); // exception


Instant nextDay = instant.plus(1, ChronoUnit.DAYS);
System.out.println(nextDay); // 2015–05–26T15:55:00Z
Instant nextHour = instant.plus(1, ChronoUnit.HOURS);
System.out.println(nextHour); // 2015–05–25T16:55:00Z
Instant nextWeek = instant.plus(1, ChronoUnit.WEEKS); // exception

It’s weird that an Instant displays a year and month while preventing you from doing
math with those fields. Unfortunately, you need to memorize this fact.


------------------------------

Accounting for Daylight Savings Time

On March 13, 2016, we move our clocks forward an hour and jump from 2:00 a.m. to 3:00 a.m. 
This means that there is no 2:30 a.m. that day. If we wanted to know the time an hour later than 1:30, 
it would be 3:30.

LocalDate date = LocalDate.of(2016, Month.MARCH, 13);
LocalTime time = LocalTime.of(1, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2016–03–13T01:30–05:00[US/Eastern]
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2016–03–13T03:30–04:00[US/Eastern]

Notice that two things change in this example. The time jumps from 1:30 to 3:30. The
UTC offset also changes. Remember when we calculated GMT time by subtracting the time
zone from the time? You can see that we went from 6:30 GMT (1:30 minus -5:00) to 7:30
GMT (3:30 minus -4:00). This shows that the time really did change by one hour from
GMT’s point of view.


Similarly in November, an hour after the initial 1:30 is also 1:30 because at 2:00 a.m.
we repeat the hour.


LocalDate date = LocalDate.of(2016, Month.NOVEMBER, 6);
LocalTime time = LocalTime.of(1, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2016–11–06T01:30–04:00[US/Eastern] //5:30GMT
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2016–11–06T01:30–05:00[US/Eastern] //6:30GMT
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2016–11–06T02:30–05:00[US/Eastern] //7:30GMT



LocalDate date = LocalDate.of(2016, Month.MARCH, 13);
LocalTime time = LocalTime.of(2, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2016–03–13T03:30–04:00[US/Eastern]


-----------------------------

Reviewing the String class

4: String s1 = "bunny";
5: String s2 = "bunny";
6: String s3 = new String("bunny");
7: System.out.println(s1 == s2); // true
8: System.out.println(s1 == s3); // false
9: System.out.println(s1.equals(s3)); // true

10: String s4 = "1" + 2 + 3;
11: String s5 = 1 + 2 + "3";
12: System.out.println(s4); // 123
13: System.out.println(s5); // 33

14: String s = "abcde ";
15: System.out.println(s.trim().length()); // 5
16: System.out.println(s.charAt(4)); // e
17: System.out.println(s.indexOf('e')); // 4
18: System.out.println(s.indexOf("de")); // 3
19: System.out.println(s.substring(2, 4).toUpperCase()); // CD
20: System.out.println(s.replace('a', '1')); // 1bcde
21: System.out.println(s.contains("DE")); // false
22: System.out.println(s.startsWith("a")); // true


3: StringBuilder b = new StringBuilder();
4: b.append(12345).append('-');
5: System.out.println(b.length()); // 6
6: System.out.println(b.indexOf("-")); // 5
7: System.out.println(b.charAt(2)); // 3
8:
9: StringBuilder b2 = b.reverse();
10: System.out.println(b.toString()); // -54321
11: System.out.println(b == b2); // true


12: StringBuilder s = new StringBuilder("abcde");
13: s.insert(1, '-').delete(3, 4); //a-bcde -> a-bde   
14: System.out.println(s); //a-bde
15: System.out.println(s.substring(2, 4)); // bd


Characteristic 	 String 	StringBuilder 	StringBuffer
Immutable? 	 Yes 		No 		No
Pooled? 	 Yes 		No 		No
Thread-safe? 	 Yes 		No 		Yes
Can change size? No 		Yes 		Yes

------------------

Adding Internationalization and Localization

java.util.Locale

Locale locale = Locale.getDefault();
System.out.println(locale);

invalid Locales:
US // can have a language without a country, but not the reverse
enUS // missing underscore
US_en // the country and language are reversed
EN // language must be lowercase

The corrected versions are en and en_US.


There are three main ways of creating a Locale . 

First, the Locale class provides constants for some of the most commonly used locales:

System.out.println(Locale.GERMAN); // de
System.out.println(Locale.GERMANY); // de_DE


The other two main ways of creating a Locale are to use the constructors. 
You can pass just a language or both a language and country:

System.out.println(new Locale("fr")); // fr
System.out.println(new Locale("hi", "IN")); // hi_IN

================= NOT IN EXAM
Locale l1 = new Locale.Builder()
.setLanguage("en")
.setRegion("US")
.build();

Locale l2 = new Locale.Builder()
.setRegion("US")
.setLanguage("en")
.build();


Locale l2 = new Locale.Builder() // bad but legal
.setRegion("us")
.setLanguage("EN")
.build();

==================

System.out.println(Locale.getDefault()); // en_US
Locale locale = new Locale("fr");
Locale.setDefault(locale); // change the default
System.out.println(Locale.getDefault()); // fr


Locale us = new Locale("en", "US");
Locale france = new Locale("fr", "FR");
Locale englishCanada = new Locale("en", "CA");
Locale frenchCanada = new Locale("fr", "CA");



Zoo_en.properties
   hello=Hello
   open=The zoo is open.
Zoo_fr.properties
   hello=Bonjour
   open=Le zoo est ouvert


1: import java.util.*;
2: public class ZooOpen {
3:
4: public static void main(String[] args) {
5:    Locale us = new Locale("en", "US");
6:    Locale france = new Locale("fr", "FR");
8:    printProperties(us);
9:    System.out.println();
10:   printProperties(france);
11: }
12:
13: public static void printProperties(Locale locale) {
14:    ResourceBundle rb = ResourceBundle.getBundle("Zoo", locale);
15:    System.out.println(rb.getString("hello"));
16:    System.out.println(rb.getString("open"));
17: }
18: }


The output is as follows:
Hello
The zoo is open.

Bonjour
Le zoo est ouvert



Property File Format
animal=dolphin
animal:dolphin
animal dolphin


# one comment
! another comment
key = value\tafter tab
long = abcdefghijklm\
nopqrstuvwxyz

Printing out these two properties in a program gives us this:

value ? after tab
abcdefghijklmnopqrstuvwxyz



The ResourceBundle class provides a method to get a set of all keys:

Locale us = new Locale("en", "US");
ResourceBundle rb = ResourceBundle.getBundle("Zoo", us);
Set<String> keys = rb.keySet();
keys.stream()
    .map(k -> k + " " + rb.getString(k))
    .forEach(System.out::println);


Properties props = new Properties();
rb.keySet()
  .stream()
  .forEach(k -> props.put(k, rb.getString(k)));


System.out.println(props.getProperty("notReallyAProperty"));
System.out.println(props.getProperty("notReallyAProperty", "123"));

The first line prints null, since that property doesn’t exist. The second prints 123, since
the property wasn’t found. If a key were passed that actually existed, both would have
returned it.


Key Found? 			Yes 	No
==========================	======	======
getProperty("key") 		Value 	null
getProperty("key", "default") 	Value 	"default"


To implement a resource bundle in Java, you create a class with the same name that you
would use for a property file. Only the extension is different. Since we have a Java object,
the file must be a .java file rather than a .properties file. For example, the following class
is equivalent to the property file that you saw in the last section:


1: import java.util.*;
2: public class Zoo_en extends ListResourceBundle {
3: protected Object[][] getContents() {
4: return new Object[][] {
5: { "hello", "Hello" },
6: { "open", "The zoo is open" } };
7: } }


There are two main advantages of using a Java class instead of a property file for a
resource bundle:
[] You can use a value type that is not a String.
[] You can create the values of the properties at runtime.


1: package resourcebundles;
2: import java.util.*;
3: public class Tax_en_US extends ListResourceBundle {
4: protected Object[][] getContents() {
5:    return new Object[][] { { "tax", new UsTaxCode() } };
6: }
7: public static void main(String[] args) {
8:    ResourceBundle rb = ResourceBundle.getBundle(
9:                        "resourcebundles.Tax", Locale.US);
10: System.out.println(rb.getObject("tax"));
11: }}

Line 3 extends the ListResourceBundle so that we can define a resource bundle. This
time, the class name specifies both the language code and country code. Lines 4–6 show
the method to declare the key/value pairs. This time, the value is not a String. Lines 8–9
show that a resource bundle can be in a package. We just specify the name of the package
before the name of the class. Line 10 shows how to retrieve a non-String resource bundle.


ResourceBundle.getBundle("name");
ResourceBundle.getBundle("name", locale);


The first one uses the default locale. You are likely to use this one in programs that you
write. The exam either tells you what to assume as the default locale or uses the second
approach.


Table 5.7 Picking a resource bundle for French in France with default locale US English

Step 		Looks for File 			Reason
1 		Zoo_fr_FR.java 			The requested locale
2 		Zoo_fr_FR.properties 		The requested locale
3 		Zoo_fr.java 			The language we requested with no country
4 		Zoo_fr.properties		The language we requested with no country
5 		Zoo_en_US.java 			The default locale
6 		Zoo_en_US.properties 		The default locale
7 		Zoo_en.java 			The default language with no country 
8 		Zoo_en.properties 		The default language with no country
9		Zoo.java 			No locale at all—the default bundle
10 		Zoo.properties 			No locale at all—the default bundle
11		If still not found, throw
		MissingResourceException.



How many files do you think Java would need to look for to find the resource bundle
with the code?

Locale.setDefault(new Locale("hi"));
ResourceBundle rb = ResourceBundle.getBundle("Zoo", new Locale("en"));


The answer is six. They are listed here:
1. Zoo_hi.java
2. Zoo_hi.properties
3. Zoo_en.java
4. Zoo_en.properties
5. Zoo.java
6. Zoo.properties

------------------------


Zoo.properties
   name=Vancouver Zoo

Zoo_en.properties
   hello=Hello
   open=is open

Zoo_en_CA.properties
   visitor=Canada visitor

Zoo_fr.properties
   hello=Bonjour  
   open=est ouvert

Zoo_fr_CA.properties
   visitor=Canada visiteur


(a default locale of French Canada)

2: Locale locale = new Locale("en", "CA");
3: ResourceBundle rb = ResourceBundle.getBundle("Zoo", locale); 
4: System.out.print(rb.getString("hello")); //Zoo_en.properties Hello
5: System.out.print(". ");
6: System.out.print(rb.getString("name")); //Zoo.properties Vancouver Zoo
7: System.out.print(" ");
8: System.out.print(rb.getString("open")); //Zoo_en.properties  is open
9: System.out.print(" ");
10: System.out.print(rb.getString("visitor")); //Zoo_en_CA.properties Canada visitor


 
-----------------

Formatting Numbers


1: import java.text.*;
2: import java.util.*;
3:
4: public class FormatNumbers {
5: public static void main(String[] args) {
6: int attendeesPerYear = 3_200_000;
7: int attendeesPerMonth = attendeesPerYear / 12;
8: NumberFormat us = NumberFormat.getInstance(Locale.US);
9: System.out.println(us.format(attendeesPerMonth));
10: NumberFormat g = NumberFormat.getInstance(Locale.GERMANY);
11: System.out.println(g.format(attendeesPerMonth));
12: NumberFormat ca = NumberFormat.getInstance(Locale.CANADA_FRENCH);
13: System.out.println(ca.format(attendeesPerMonth));
14: } }
The output looks like this:
266,666
266.666
266 666


double price = 48;
NumberFormat us = NumberFormat.getCurrencyInstance();
System.out.println(us.format(price));
When run with the default locale of en_US , the output is $48.00. Java automatically formats
with two decimals and adds the dollar sign. This is convenient even if you don’t need
to localize your program!


Parsing

The parse methods for the different types of formats throw the checked exception
ParseException if they fail to parse.
You can assume that exceptions are properly handled.
If you see parsing logic inside a method, make sure that ParseException or Exception is
handled or declared.

NumberFormat en = NumberFormat.getInstance(Locale.US);
NumberFormat fr = NumberFormat.getInstance(Locale.FRANCE);
String s = "40.45";
System.out.println(en.parse(s)); // 40.45
System.out.println(fr.parse(s)); // 40

In the United States, a dot is part of a number and the number is parsed how you might
expect. France does not use a decimal point to separate numbers. Java parses it as a formatting
character, and it stops looking at the rest of the number. The lesson is to make sure
that you parse using the right locale!



NumberFormat nf = NumberFormat.getInstance();
String one = "456abc";
String two = "-2.5165x10";
String three = "x85.3";
System.out.println(nf.parse(one)); // 456
System.out.println(nf.parse(two)); // -2.5165
System.out.println(nf.parse(three));// throws ParseException

The first two lines parse correctly. There happen to be extra characters after the number,
but that’s OK. The third parsing fails because there are no numbers at the beginning of
the String. Java instead throws a java.text.ParseException.

String amt = "$92,807.99";
NumberFormat cf = NumberFormat.getCurrencyInstance();
double value = (Double) cf.parse(amt);
System.out.println(value); // 92807.99 

The currency string "$92,807.99" contains a dollar sign and a comma. The parse
method strips out the characters and converts the value to a number. The return value of
parse is a Number object. Number is the parent class of all the java.lang wrapper classes, so
the return value can be cast to its appropriate data type. The Number is cast to a Double and
then automatically unboxed into a double.


Formatting Dates and Times

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
System.out.println(date.getDayOfWeek()); // MONDAY
System.out.println(date.getMonth()); // JANUARY
System.out.println(date.getYear()); // 2020
System.out.println(date.getDayOfYear()); // 20


LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);
System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME));
System.out.println(dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));

2020–01–20
11:12:34
2020–01–20T11:12:34


DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
System.out.println(shortDateTime.format(dateTime)); // 1/20/20
System.out.println(shortDateTime.format(date)); // 1/20/20
System.out.println(shortDateTime.format(time)); // UnsupportedTemporalTypeException

The last line throws an exception because a time cannot be formatted as a date


The following statements print exactly the same thing as the previous code:

DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
System.out.println(dateTime.format(shortDateTime));
System.out.println(date.format(shortDateTime));
System.out.println(time.format(shortDateTime));



Table 5.10 - vizualizar --


LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);
DateTimeFormatter shortF = DateTimeFormatter
.ofLocalizedDateTime(FormatStyle.SHORT);
DateTimeFormatter mediumF = DateTimeFormatter
.ofLocalizedDateTime(FormatStyle.MEDIUM);
System.out.println(shortF.format(dateTime)); // 1/20/20 11:12 AM
System.out.println(mediumF.format(dateTime)); // Jan 20, 2020 11:12:34 AM


DateTimeFormatter f = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm");
System.out.println(dateTime.format(f)); // January 20, 2020, 11:12

MMMM M represents the month. The more Ms you have, the more verbose the Java output. For
example, M outputs 1, MM outputs 01, MMM outputs Jan, and MMMM outputs January.
dd d represents the day in the month. As with month, the more ds you have, the more verbose
the Java output. dd means to include the leading zero for a single-digit day.
, Use , if you want to output a comma (this also appears after the year).
yyyy y represents the year. yy outputs a two-digit year and yyyy outputs a four-digit year.
hh h represents the hour. Use hh to include the leading zero if you’re outputting a single-digit hour.
: Use : if you want to output a colon.
mm m represents the minute omitting the leading zero if present. mm is more common and
represents the minutes using two digits


DateTimeFormatter f = DateTimeFormatter.ofPattern("MM dd yyyy");
LocalDate date = LocalDate.parse("01 02 2015", f);
LocalTime time = LocalTime.parse("11:22");
System.out.println(date); // 2015–01–02
System.out.println(time); // 11:22


Cap 6 - Exceptions and Assertions

ArithmeticException 
	Thrown by the JVM when code attempts to divide by zero.
ArrayIndexOutOfBoundsException 
	Thrown by the JVM when code uses an illegal index to access an array.
ClassCastException 
	Thrown by the JVM when an attempt is made to cast an object to a subclass of which it is not an instance.
IllegalArgumentException 
	Thrown by the program to indicate that a method has been passed an illegal or inappropriate argument.
NullPointerException 
	Thrown by the JVM when there is a null reference where an object is required.
NumberFormatException 
	Thrown by the program when an attempt is made to convert a string to a numeric type, 
	but the string doesn’t have an appropriate format.


remember that IO, parsing, and SQL exceptions are checked. Anything else is a runtime
exception unless the exam states otherwise


java.text.ParseException 	Converting a String to a number. 	Checked 	Chapter 5



10: public String getDataFromDatabase() throws SQLException {
11: throw new UnsupportedOperationException();
12: }



1: class CannotSwimException extends Exception {}
2: class DangerInTheWater extends RuntimeException {}
3: class SharkInTheWaterException extends DangerInTheWater {}
4: class Dolphin {
5:    public void swim() throws CannotSwimException {
6:    // logic here
7:    }
8: }



public class CannotSwimException extends Exception {
	public CannotSwimException() {
   		super();
	}
	public CannotSwimException(Exception e) {
		super(e);
	}
	public CannotSwimException(String message) {
		super(message);
	}
}


1
Exception in thread "main" CannotSwimException
at CannotSwimException.main(CannotSwimException.java:18)

2
Exception in thread "main" CannotSwimException: java.lang.RuntimeException
at CannotSwimException.main(CannotSwimException.java:19)
Caused by: java.lang.RuntimeException
... 1 more

3
Exception in thread "main" CannotSwimException: broken fin
at CannotSwimException.main(CannotSwimException.java:20)


You can also print the stack trace on your own:

try {
   throw new CannotSwimException();
} catch (CannotSwimException e) {
   e.printStackTrace();
}


public static void main(String[] args) {
try {
   Path path = Paths.get("dolphinsBorn.txt");
   String text = new String(Files.readAllBytes(path));
   LocalDate date = LocalDate.parse(text);
   System.out.println(date);
} catch (DateTimeParseException | IOException e) { 
   e.printStackTrace();
   throw new RuntimeException(e);
} 
}


catch(Exception1 e | Exception2 e | Exception3 e) // DOES NOT COMPILE
catch(Exception1 e1 | Exception2 e2 | Exception3 e3) // DOES NOT COMPILE
catch(Exception1 | Exception2 | Exception3 e)

try {
  throw new IOException();
} catch (FileNotFoundException | IOException e) { } // DOES NOT COMPILE

	
LEGAL:

try {
// do some work
} catch(RuntimeException e) {
   e = new RuntimeException(); //ONLY WHEN  class = subClass or Class 
}

ILEGAL:

try {
throw new IOException();
} catch(IOException | RuntimeException e) {
   e = new RuntimeException(); // DOES NOT COMPILE
}


11: public void doesNotCompile() { // METHOD DOES NOT COMPILE
12: try {
13: mightThrow();
14: } catch (FileNotFoundException | IllegalStateException e) {
15: } catch (InputMismatchException e | MissingResourceException e) {
16: } catch (SQLException | ArrayIndexOutOfBoundsException e) {
17: } catch (FileNotFoundException | IllegalArgumentException e) {
18: } catch (Exception e) {
19: } catch (IOException e) {
20: }
21: }
22: private void mightThrow() throws DateTimeParseException, IOException { }

[] Line 15 has an extra variable name. Remember that there can be only one exception
variable per catch block.
[] their subclasses. While this doesn’t have anything to do with multi-catch, you’ll see
“regular” catch block problems mixed in with multi-catch.
[] Line 17 cannot catch FileNotFoundException because that exception was already
caught on line 15. You can’t list the same exception type more than once in the same
try statement, just like with “regular” catch blocks.
[] Line 16 cannot catch SQLException because nothing in the try statement can
potentially throw one. Again, just like “regular” catch blocks, any runtime exception
may be caught. However, only checked exceptions that have the potential to be thrown
are allowed to be caught.


30: public void newApproach(Path path1, Path path2) throws IOException {
31: try (BufferedReader in = Files.newBufferedReader(path1);
32: BufferedWriter out = Files.newBufferedWriter(path2)) {
33: out.write(in.readLine());
34: }
35: }

33: out.write(in.readLine());
34: }
35: }



try-with-resources statement is still allowed to have catch and/or finally blocks.


3: try (Scanner s = new Scanner(System.in)) {
4:    s.nextLine();
5: } catch(Exception e) {
6:    s.nextInt(); // DOES NOT COMPILE
7: } finally{
8:    s.nextInt(); // DOES NOT COMPILE
9: }




public class Turkey {
public static void main(String[] args) {
try (Turkey t = new Turkey()) { // DOES NOT COMPILE
System.out.println(t);
}
}
}

Java doesn’t allow this. It has no idea how to close a Turkey. Java informs us of this fact
with a compiler error:
The resource type Turkey does not implement java.lang.AutoCloseable



1: public class TurkeyCage implements AutoCloseable {
2: public void close() {
3: System.out.println("Close gate");
4: }
5: public static void main(String[] args) {
6: try (TurkeyCage t = new TurkeyCage()) {
7: System.out.println("put turkeys in");
8: }
9: }
10: }


The AutoCloseable interface has only one method to implement:
public void close() throws Exception;


public class StuckTurkeyCage implements AutoCloseable {
public void close() throws Exception {
throw new Exception("Cage door does not close");
}
public static void main(String[] args) {
try (StuckTurkeyCage t = new StuckTurkeyCage()) { // DOES NOT COMPILE
System.out.println("put turkeys in");
}
}
}




27: try (JammedTurkeyCage t1 = new JammedTurkeyCage();
28: JammedTurkeyCage t2 = new JammedTurkeyCage()) {
29: System.out.println("turkeys entered cages");
30: } catch (IllegalStateException e) {
31: System.out.println("caught: " + e.getMessage());
32: for (Throwable t: e.getSuppressed())
33: System.out.println(t.getMessage());
34: }

On line 29, the turkeys enter the cages without exception. Then Java tries to close both
cages automatically. t2 is closed first, since Java closes resources in the reverse order from
which it created them. This throws an exception. Since it is the first exception to occur,
it becomes the primary exception. Then t1 is closed. Since an exception has already been
thrown, this one becomes a suppressed exception. The output is
turkeys entered cages
caught: Cage door does not close
Cage door does not close

Finally, keep in mind that suppressed exceptions apply only to exceptions thrown in the
try clause. The following example does not throw a suppressed exception:
35: try (JammedTurkeyCage t = new JammedTurkeyCage()) {
36: throw new IllegalStateException("turkeys ran off");
37: } finally {
38: throw new RuntimeException("and we couldn't find them");
39: }
Line 36 throws an exception. Then Java tries to close the resource and adds a suppressed
exception to it. Now we have a problem. The finally block runs after all this. Since line
38 throws an exception, the previous exception is lost. This has always been and continues
to be bad programming practice. We don’t want to lose exceptions.


[] Resources are closed after the try clause ends and before any catch/finally clauses.
[] Resources are closed in the reverse order from which they were created.


public class Auto implements AutoCloseable {
int num;
Auto(int num) { this.num = num; }
public void close() {
System.out.println("Close: " + num);
}
public static void main(String[] args) {
try (Auto a1 = new Auto(1); Auto a2 = new Auto(2)) {
throw new RuntimeException();
} catch (Exception e) {
System.out.println("ex");
} finally {
System.out.println("finally");
}
}
}


close 2
close 1 
ex
finally

------

Rethrowing Exceptions

public void parseData() throws SQLException, DateTimeParseException {}

When calling this method, we need to handle or declare those two exception types.
There are few valid ways of doing this. We could have two catch blocks and duplicate the
logic. Or we could use multi-catch:

3: public void multiCatch() throws SQLException, DateTimeParseException {
4:   try {
5:      parseData();
6:   } catch (SQLException | DateTimeParseException e) {
7:      System.err.println(e);
8:      throw e;
9: } }


3: public void rethrowing() throws SQLException, DateTimeParseException {
4: try {
5:    parseData();
6: } catch (Exception e) {
7:    System.err.println(e);
8;    throw e;
9: } }

We still have one catch block on line 6. This time, Java interprets Exception as the possible
exceptions that can be thrown in the method. As long as all of these checked exceptions
are handled or declared, Java is happy.



-----------

Working with Assertions

The syntax for an assert statement has two forms:

assert boolean_expression;
assert boolean_expression: error_message;

That’s right. An assertion throws an AssertionError if it is false. Since programs aren’t
supposed to catch an Error , this means that assertion failures are fatal and end the program.


[] If assertions are disabled, Java skips the assertion and goes on in the code.
[] If assertions are enabled and the boolean expression is true , then our assertion has
been validated and nothing happens. The program continues to execute in its normal
manner.
[] If assertions are enabled and the boolean expression is false , then our assertion is
invalid and a java.lang.AssertionError is thrown.


java –ea Assertions:
1: public class Assertions {
2: public static void main(String[] args) {
3:    int numGuests = -5;
4:    assert numGuests > 0;
5:    System.out.println(numGuests);
6: }
7: }


The program ends with a stack trace similar to this:
Exception in thread "main" java.lang.AssertionError
at asserts.Assertions.main(Assertions.java:7)


Enabling Assertions:

java -enableassertions Rectangle
You can also use the shortcut -ea flag:
java -ea Rectangle


the following command enables assertions only
for classes in the com.wiley.demos package and any subpackages:

java -ea:com.wiley.demos... my.programs.Main


The three dots means any class in the specified package or subpackages. You can also
enable assertions for a specific class:

java -ea:com.wiley.demos.TestColors my.programs.Main


You can disable assertions using the -disableassertions (or -da ) fl ag for a specifi c

For example, the following command enables
assertions for the com.wiley.demos package but disables assertions for the TestColors
class:
java -ea:com.wiley.demos... -da:com.wiley.demos.TestColors my.programs.Main
'


1: public class TestSeasons {
2: public static void test(Seasons s) {
3: switch (s) {
4: case SPRING:
5: case FALL:
6: System.out.println("Shorter hours");
7: break;
8: case SUMMER:
9: System.out.println("Longer hours");
10: break;
11: default:
12: assert false: "Invalid season";
13: }}}


CAP 7 : 

The property of executing multiple threads and processes at the same time is referred to as concurrency

A context switch is the process of storing a thread’s current state and later restoring the state of the thread to continue execution

A thread priority is a numeric value associated with a thread that is taken into consideration by the thread scheduler when determining which threads should currently be executing.


--Runnable

@FunctionalInterface public interface Runnable {
   void run();
}



The Runnable interface is commonly used to define the work a thread will execute,
separate from the main application thread.

Valid:
() -> System.out.println("Hello World")
() -> {int i=10; i++;}
() -> {return;}
() -> {}




Invalid with Runnable: 

() -> ""
() -> 5
() -> {return new Object();}


Runnable before java7 (used yet): 

public class CalculateAverage implements Runnable {
   public void run() {
     // Define work here
   }
}


Creating a Thread

[] Provide a Runnable object or lambda expression to the Thread constructor.
[] Create a class that extends Thread and overrides the run() method.


public class PrintData implements Runnable {
   public void run() {
      for(int i=0; i<3; i++)
         System.out.println("Printing record: "+i);
   }
   public static void main(String[] args) {
      (new Thread(new PrintData())).start();
   }
}


public class ReadInventoryThread extends Thread {
    public void run() {
       System.out.println("Printing zoo inventory");
    }
    public static void main(String[] args) {
       (new ReadInventoryThread()).start();
    }
}

Anytime you create a Thread instance, make sure that you remember to start the task with the Thread.start() method. This starts the task in a separate operating system thread.


public static void main(String[] args) {
System.out.println("begin");
(new ReadInventoryThread()).start();
(new Thread(new PrintData())).start();
(new ReadInventoryThread()).start();
System.out.println("end");
}

The answer is that it is unknown until runtime. For example, the following is just one
possible output:

begin
Printing zoo inventory
Printing record: 0
end
Printing zoo inventory
Printing record: 1
Printing record: 2



While the following code snippets will compile, none will actually execute a task on a separate processing thread. 
Instead, the thread that made the call will be used to execute the task, causing the thread to wait until each run() method is complete before moving on to the next line.
new PrintData().run();
(new Thread(new PrintData())).run();
(new ReadInventoryThread()).run();

==============

Polling with Sleep

Polling is the process of intermittently checking data at some fixed interval.

public class CheckResults throws InterruptedException{
  private static int counter = 0;
  public static void main(String[] args) {
     new Thread(() -> { for(int i=0; i<500; i++) CheckResults.counter++; }).start();
     while(CheckResults.counter<100) {
        System.out.println("Not reached yet");
	Thread.sleep(1000); // 1 SECOND
     } 
     System.out.println("Reached!");
  }
}

=====

Creating Threads with the ExecutorService

import java.util.concurrent.*;
public class ZooInfo {
   public static void main(String[] args) {
	ExecutorService service = null;
	try {
	   service = Executors.newSingleThreadExecutor();
	   System.out.println("begin");
	   service.execute(() -> System.out.println("Printing zoo inventory"));
	   service.execute(() -> {for(int i=0; i<3; i++) System.out.println("Printing record: "+i);});
	   service.execute(() -> System.out.println("Printing zoo inventory"));
	   System.out.println("end");
	} finally {
	   if(service != null) service.shutdown();
	}
   }
}


begin
Printing zoo inventory
Printing record: 0
Printing record: 1
end
Printing record: 2
Printing zoo inventory

With a single-thread executor, results are guaranteed to be executed in the order in which
they are added to the executor service. Notice that the end text is output while our thread
executor tasks are still running. This is because the main() method is still an independent
thread from the ExecutorService, and it can perform tasks while the other thread is running.



Shutting Down a Thread Executor

Once you have finished using a thread executor, it is important that you call the
shutdown() method. A thread executor creates a non-daemon thread on the first task that
is executed, so failing to call shutdown() will result in your application never terminating.

The shutdown process for a thread executor involves first rejecting any new tasks submitted to
the thread executor while continuing to execute any previously submitted tasks. During this time,
calling isShutdown() will return true, while isTerminated() will return false. If a new task is
submitted to the thread executor while it is shutting down, a RejectedExecutionException will
be thrown. Once all active tasks have been completed, isShutdown() and isTerminated() will
both return true.

What if you want to cancel all running
and upcoming tasks? The ExecutorService provides a method called shutdownNow(), which
attempts to stop all running tasks and discards any that have not been started yet. Lastly, shutdownNow()
returns a List<Runnable> of tasks that were submitted to the thread executor but that were
never started.

=== 

Submitting Tasks

Method 					Name Description
void execute(Runnable command) 		Executes a Runnable task at some point in the future

Future<?> submit(Runnable task)		Executes a Runnable task at some point in the future and returns a Future
					representing the task

<T> Future<T> submit(Callable<T> task)  Executes a Callable task at some point in the future and returns a Future
					representing the pending results of the task

<T> List<Future<T>> invokeAll(		 Executes the given tasks, synchronously returning the results of all tasks
Collection<? extends Callable<T>> tasks) as a Collection of Future objects, in the same order they were in the original
throws InterruptedException		 collection
		
<T> T invokeAny(			 Executes the given tasks, synchronously returning the result of one of
Collection<? extends Callable<T>> tasks) finished tasks, cancelling any unfinished tasks.
throws InterruptedException,
ExecutionException



In practice, using the submit() method is quite similar to using the execute() method, except that the submit() method return a Future object that can be used to determine whether or not the task has completed execution.

----

Submitting Task Collections

By synchronous, we mean that unlike the other methods used to submit tasks to a thread executor, these methods will wait
until the results are available before returning control to the enclosing program.
The invokeAll() method executes all tasks in a provided collection and returns a List of
ordered Future objects, with one Future object corresponding to each submitted task, in the
order they were in the original collection. Even though Future.isDone() returns true for each
element in the returned List, a task could have completed normally or thrown an exception


The invokeAny() method executes a collection of tasks and returns the result of one of
the tasks that successfully completes execution, cancelling all unfinished tasks. While the
first task to finish is often returned, this behavior is not guaranteed, as any completed task
can be returned by this method


Finally, the invokeAll() method will wait indefinitely until all tasks are complete,
while the invokeAny() method will wait indefinitely until at least one task completes


=================


Waiting for Results


Future<?> future = service.submit(() -> System.out.println("Hello Zoo"));

Method 				Name Description

boolean isDone()		Returns true if the task was completed, threw an exception, or was cancelled.


boolean isCancelled() 		Returns true if the task was cancelled before it completely normally.

boolean cancel() 		Attempts to cancel execution of the task.

V get() 			Retrieves the result of a task, waiting endlessly if it is not yet available.

V get(long timeout,		Retrieves the result of a task, waiting the specified amount of time. If the result is not
TimeUnit unit)			ready by the time the timeout is reached, a checked TimeoutException will be thrown.




import java.util.concurrent.*;
public class CheckResults {
	private static int counter = 0;
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		ExecutorService service = null;
		try {
			service = Executors.newSingleThreadExecutor();
			Future<?> result = service.submit(() -> {for(int i=0; i<500; i++) CheckResults.counter++;});
			result.get(10, TimeUnit.SECONDS);
			System.out.println("Reached!");
		} catch (TimeoutException e) {
			System.out.println("Not reached in time");
		} finally {
			if(service != null) service.shutdown();
		}
	}
}




What is the return value of this task? As Future<V> is a generic class, the type V
is determined by the return type of the Runnable method. Since the return type of
Runnable.run() is void, the get() method always returns null. In the next section, you
will see that there is another task class compatible with ExecutorService that supports
other return types.



TimeUnit.NANOSECONDS 	Time in one-billionth of a second (1/1,000,000,000)
TimeUnit.MICROSECONDS 	Time in one-millionth of a second (1/1,000,000)
TimeUnit.MILLISECONDS 	Time in one-thousandth of a second (1/1,000)
TimeUnit.SECONDS 	Time in seconds
TimeUnit.MINUTES 	Time in minutes
TimeUnit.HOURS 		Time in hours
TimeUnit.DAYS 		Time in days


==========================

Introducing Callable

@FunctionalInterface public interface Callable<V> {
	V call() throws Exception;
}



public class AddData {
public static void main(String[] args) throws InterruptedException,ExecutionException {
	ExecutorService service = null;
	try {
		service = Executors.newSingleThreadExecutor();
		Future<Integer> result = service.submit(() -> 30+11);
		System.out.println(result.get());
	} finally {
		if(service != null) service.shutdown();
	}
}
}



service.submit(() -> {Thread.sleep(1000); return null;});
service.submit(() -> {Thread.sleep(1000);});
The first line will compile, while the second line will not. Why? Recall that Thread.
sleep() throws a checked InterruptedException. Since the first lambda expression
has a return type, the compiler treats this as a Callable expression that supports
checked exceptions. The second lambda expression does not return a value; therefore,
the compiler treats this as a Runnable expression. Since Runnable methods do not support
checked exceptions, the compiler will report an error trying to compile this code
snippet.

----------------

Waiting for All Tasks to Finish

If we don’t need the results of the tasks and are finished using our thread executor, there is a simpler approach.
First, we shut down the thread executor using the shutdown() method. Next, we use the 
awaitTermination(long timeout, TimeUnit unit) method available for all thread executors. The method waits the specified time to complete all tasks, returning sooner if all tasks finish or an InterruptedException is detected. You can see an example of this in the following code snippet:

ExecutorService service = null;
try {
   service = Executors.newSingleThreadExecutor();
   // Add tasks to the thread executor
   ...
} finally { 
   if(service != null) service.shutdown();
}
if(service != null) {
   service.awaitTermination(1, TimeUnit.MINUTES);
   // Check whether all tasks are finished
   if(service.isTerminated())
      System.out.println("All tasks finished");
   else
      System.out.println("At least one task is still running");
}


In this example, we submit a number of tasks to the thread executor and then shut down
the thread executor and wait up to one minute for the results. Notice that we can call
isTerminated() after the awaitTermination() method finishes to confirm that all tasks
are actually finished.

=====

Scheduling Tasks

The ScheduledExecutorService, which is a subinterface of ExecutorService,

ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();


Method Name 			Description
schedule(Callable<V> callable,	Creates and executes a Callable task after the given delay
long delay, TimeUnit unit)

schedule(Runnable command,	Creates and executes a Runnable task after the given delay
long delay, TimeUnit unit)

scheduleAtFixedRate(Runnable	Creates and executes a Runnable task after the given initial delay,	
command, long initialDelay,     creating a new task every period value that passes.
long period, TimeUnit unit)

scheduleAtFixedDelay(Runnable   Creates and executes a Runnable task after the given initial delay and subsequently
command, long initialDelay,     with the given delay between the termination of one execution and the commencement
long delay, TimeUnit unit)      of the next


The fi rst two schedule() methods in Table 7.5 take a Callable or Runnable ,
respectively, perform the task after some delay, and return a ScheduledFuture<V>
instance. ScheduledFuture<V> is identical to the Future<V> class, except that it includes a
getDelay() method that returns the delay set when the process was created. The following
uses the schedule() method with Callable and Runnable tasks:

ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();
Runnable task1 = () -> System.out.println("Hello Zoo");
Callable<String> task2 = () -> "Monkey";
Future<?> result1 = service.schedule(task1, 10, TimeUnit.SECONDS);
Future<?> result2 = service.schedule(task2, 8, TimeUnit.MINUTES);

The first task is scheduled 10 seconds in the future, whereas the second task is scheduled
8 minutes in the future.


The scheduleAtFixedRate() method creates a new task and submits it to the executor
every period, regardless of whether or not the previous task finished. The following example
executes a Runnable task every minute, following an initial five-minute delay:

service.scheduleAtFixedRate(command,5,1,TimeUnit.MINUTE);


On the other hand, the scheduleAtFixedDelay() method creates a new task after the
previous task has fi nished. For example, if the fi rst task runs at 12:00 and takes fi ve minutes
to fi nish, with a period of 2 minutes, then the second task will start at 12:07.

service.scheduleAtFixedDelay(command,0,2,TimeUnit.MINUTE);


===================


Increasing Concurrency with Pools

Method Name 			Return Type 		Description
newSingleThreadExecutor() 	ExecutorService		Creates a single-threaded executor that uses a single worker thread 							operating off an unbounded queue. Results are processed 									sequentially in the order in which they are submitted.

newSingleThreadScheduled	Scheduled		Creates a single-threaded executor that can schedule commands
Executor()			ExecutorService		to run after a given delay or to execute periodically.

newCachedThreadPool()		ExecutorService		Creates a thread pool that creates new threads as needed,
							but will reuse previously constructed threads when they
							are available. 

newFixedThreadPool(int		ExecutorService		Creates a thread pool that reuses a fixed number of threads 
nThreads)						operating off a shared unbounded queue.

newScheduledThreadPool(int	Scheduled		Creates a thread pool that can schedule commands to run after
nThreads)			ExecutorService		a given delay or to execute periodically.

The difference between a single-thread and a pooled-thread executor is what happens when a task is already running. While a single-thread executor will wait for an available thread to become available before running the next task, a pooled-thread executor can execute the next task concurrently. If the pool runs out of available threads, the task will be
queued by the thread executor and wait to be completed.


The newCachedThreadPool() method will create a thread pool of unbounded size,
allocating a new thread anytime one is required or all existing threads are busy. This is
commonly used for pools that require executing many short-lived asynchronous tasks. For
long-lived processes, usage of this executor is strongly discouraged, as it could grow to
encompass a large number of threads over the application life cycle.


The newFixedThreadPool() takes a number of threads and allocates them all upon
creation. As long as our number of tasks is less than our number of threads, all tasks
will be executed concurrently. If at any point the number of tasks exceeds the number
of threads in the pool, they will wait in similar manner as you saw with a single-thread
executor. In fact, calling newFixedThreadPool() with a value of 1 is equivalent to calling
newSingleThreadExecutor().


The newScheduledThreadPool() is identical to the newFixedThreadPool() method,
except that it returns an instance of ScheduledExecutorService and is therefore
compatible with scheduling tasks. This executor has subtle differences in the way that the
scheduleAtFixedRate() performs. For example, recall our previous example in which
tasks took five minutes to complete:

ScheduledExecutorService service = Executors.newScheduledThreadPool(10);
service.scheduleAtFixedRate(command,3,1,TimeUnit.MINUTE)

================================


Synchronizing Data Access


java.util.concurrent.atomic

Class Name 		Description
AtomicBoolean 		A boolean value that may be updated atomically
AtomicInteger 		An int value that may be updated atomically
AtomicIntegerArray 	An int array in which elements may be updated atomically
AtomicLong 		A long value that may be updated atomically
AtomicLongArray 	A long array in which elements may be updated atomically
AtomicReference 	A generic object reference that may be updated atomically
AtomicReferenceArray 	An array of generic object references in which elements may be updated atomically



Class Name 		Description
get() 			Retrieve the current value
set() 			Set the given value, equivalent to the assignment = operator
getAndSet() 		Atomically sets the new value and returns the old value
incrementAndGet() 	For numeric classes, atomic pre-increment operation equivalent to  ++value
getAndIncrement() 	For numeric classes, atomic post-increment operation equivalent to value++
decrementAndGet() 	For numeric classes, atomic pre-decrement operation equivalent to --value
getAndDecrement() 	For numeric classes, atomic post-decrement operation equivalent to value--
	

private AtomicInteger sheepCount = new AtomicInteger(0);

private void incrementAndReport() {
   System.out.print(sheepCount.incrementAndGet()+" ");
}



Improving Access with Synchronized Blocks

SheepManager manager = new SheepManager();
synchronized(manager) {
   // Work to be completed by one thread at a time
}



private int sheepCount = 0;
private void incrementAndReport() {
   synchronized(this) {
      System.out.print((++sheepCount)+" ");
   }
}


Synchronizing Methods

private synchronized void incrementAndReport() {
   System.out.print((++sheepCount)+" ");
}


We can also add the synchronized modifier to static methods. What object is used as
the monitor when we synchronize on a static method? The class object, of course!

public static void printDaysWork() {
   synchronized(SheepManager.class) {
      System.out.print("Finished work");
   }
}
public static synchronized void printDaysWork() {
   System.out.print("Finished work");
}

Understanding the Cost of Synchronization

For example, let’s say that we have a highly concurrent class with numerous methods
that synchronize on the same object. Let’s say that 50 concurrent threads access it. Let’s
also say that, on average, each thread takes a modest 100 milliseconds to execute.

50 threads x 100 milliseconds
= 5,000 milliseconds
= 5 seconds


=============================================

Using Concurrent Collections

private Map<String,Object> foodData = new ConcurrentHashMap<String,Object>();


Understanding Memory Consistency Errors

A memory consistency error occurs when two threads have inconsistent views of what should be the same data. Conceptually, we want writes on one thread to be available to another thread if it accesses the concurrent collection after the write has occurred.

When two threads try to modify the same non-concurrent collection, the JVM may throw a ConcurrentModificationException at runtime. In fact, it can happen with a single thread. Take a look at the following code snippet:

Map<String, Object> foodData = new HashMap<String, Object>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
for(String key: foodData.keySet())
foodData.remove(key);

This snippet will throw a ConcurrentModificationException at runtime, since the iterator keyset() is not properly updated after the first element is removed.

Map<String, Object> foodData = new ConcurrentHashMap<String, Object>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
for(String key: foodData.keySet())
foodData.remove(key); //ok with the concurrent


Working with Concurrent Classes


Class Name		Java Collections Framework Interface	Elements Ordered? 	Sorted? 	Blocking?
ConcurrentHashMap	ConcurrentMap 				No 			No 		No
ConcurrentLinkedDeque 	Deque 					Yes 			No 		No
ConcurrentLinkedQueue 	Queue 					Yes 			No 		No
ConcurrentSkipListMap 	ConcurrentMap|SortedMap|NavigableMap	Yes 			Yes 		No
ConcurrentSkipListSet 	SortedSet|NavigableSet			Yes 			Yes 		No
CopyOnWriteArrayList 	List 					Yes 			No 		No
CopyOnWriteArraySet 	Set 					No 			No 		No
LinkedBlockingDeque 	BlockingQueue|BlockingDeque		Yes 			No 		Yes
LinkedBlockingQueue 	BlockingQueue 				Yes 			No 		Yes




Map<String,Integer> map = new ConcurrentHashMap<>();
map.put("zebra", 52);
map.put("elephant", 10);
System.out.println(map.get("elephant"));

Queue<Integer> queue = new ConcurrentLinkedQueue<>();
queue.offer(31);
System.out.println(queue.peek());
System.out.println(queue.poll());

Deque<Integer> deque = new ConcurrentLinkedDeque<>();
deque.offer(10);
deque.push(4);
System.out.println(deque.peek());
System.out.println(deque.pop());



Understanding Blocking Queues


BlockingQueue waiting methods
Method Name 				Description
offer(E e, long timeout,TimeUnit unit)	Adds item to the queue waiting the specified time,returning false if time 
					elapses before space is available

poll(long timeout, TimeUnit unit)	Retrieves and removes an item from the queue, waiting the specified time, 
					returning null if the time elapses before the item is available


try {
	BlockingQueue<Integer> blockingQueue = new LinkedBlockingQueue<>();
	blockingQueue.offer(39);
	blockingQueue.offer(3, 4, TimeUnit.SECONDS);
	System.out.println(blockingQueue.poll());
	System.out.println(blockingQueue.poll(10, TimeUnit.MILLISECONDS));
} catch (InterruptedException e) {
	// Handle interruption
}

 

BlockingDeque waiting methods
Method Name 					Description
offerFirst(E e, longtimeout, TimeUnit unit)	Adds an item to the front of the queue, waiting a specified time,
						returning false if time elapses before space is available.

offerLast(E e, long timeout,TimeUnit unit)	Adds an item to the tail of the queue, waiting a specified time,
						returning false if time elapses before space is available	

pollFirst(long timeout,TimeUnit unit)		Retrieves and removes an item from the front of the queue,
						waiting the specified time, returning null if the 
						time elapses before the item is available						
pollLast(long timeout,TimeUnit unit)		Retrieves and removes an item from the tail of the queue,
						waiting the specified time, returning null if the time elapses 
						before the item is available



try {
	BlockingDeque<Integer> blockingDeque = new LinkedBlockingDeque<>();
	blockingDeque.offer(91);
	blockingDeque.offerFirst(5, 2, TimeUnit.MINUTES);
	blockingDeque.offerLast(47, 100, TimeUnit.MICROSECONDS);
	blockingDeque.offer(3, 4, TimeUnit.SECONDS);
	System.out.println(blockingDeque.poll());
	System.out.println(blockingDeque.poll(950, TimeUnit.MILLISECONDS));
	System.out.println(blockingDeque.pollFirst(200, TimeUnit.NANOSECONDS));
	System.out.println(blockingDeque.pollLast(1, TimeUnit.SECONDS));
} catch (InterruptedException e) {
	// Handle interruption
}



Understanding SkipList Collections

The SkipList classes, ConcurrentSkipListSet and ConcurrentSkipListMap, are concurrent versions of their sorted counterparts, TreeSet and TreeMap, respectively. They maintain their elements or keys in the natural ordering of their elements.


Understanding CopyOnWrite Collections

These classes copy all of their elements to a new underlying structure anytime an element is added, modifi ed, or removed from the collection. By a modifi ed element, we mean that the reference in the collection is changed. Modifying the actual contents of the collection will not cause a new structure to be allocated.

Although the data is copied to a new underlying structure, our reference to the object does not change.

List<Integer> list = new CopyOnWriteArrayList<>(Arrays.asList(4,3,52));
for(Integer item: list) {
System.out.print(item+" ");
list.add(9);
}
System.out.println();
System.out.println("Size: "+list.size());

When executed as part of a program, this code snippet outputs the following:

4 3 52
Size: 6


Alternatively, if we had used a regular ArrayList object, a ConcurrentModificationException would have been
thrown at runtime.


The CopyOnWrite classes can use a lot of memory, since a new collection structure needs be allocated anytime the collection is modified.


Obtaining Synchronized Collections


Method Name
synchronizedCollection(Collection<T> c)
synchronizedList(List<T> list)
synchronizedMap(Map<K,V> m)
synchronizedNavigableMap(NavigableMap<K,V> m)
synchronizedNavigableSet(NavigableSet<T> s)
synchronizedSet(Set<T> s)
synchronizedSortedMap(SortedMap<K,V> m)
synchronizedSortedSet(SortedSet<T> s)


List<Integer> list = Collections.synchronizedList(new ArrayList<>(Arrays.asList(4,3,52)));
synchronized(list) {
for(int data: list)
System.out.print(data+" ");
}


Unlike the concurrent collections, the synchronized collections also throw an exception
if they are modifi ed within an iterator by a single thread. For example, take a look at the
following modifi cation of our earlier example:

Map<String, Object> foodData = new HashMap<String, Object>();
foodData.put("penguin", 1);
foodData.put("flamingo", 2);
Map<String,Object> synchronizedFoodData = Collections.synchronizedMap(foodData);
for(String key: synchronizedFoodData.keySet())
  synchronizedFoodData.remove(key);


========================

Working with Parallel Streams

Creating Parallel Streams


parallel()
The fi rst way to create a parallel stream is from an existing stream
Stream<Integer> stream = Arrays.asList(1,2,3,4,5,6).stream();
Stream<Integer> parallelStream = stream.parallel();

Be aware that parallel() is an intermediate operation that operates on the original
stream.


parallelStream()
The second way to create a parallel stream is from a Java collection class.
Stream<Integer> parallelStream2 = Arrays.asList(1,2,3,4,5,6).parallelStream();


Processing Tasks in Parallel

Arrays.asList(1,2,3,4,5,6)
.stream()
.forEach(s -> System.out.print(s+" ")); //1 2 3 4 5 6


Arrays.asList(1,2,3,4,5,6)
.parallelStream()
.forEach(s -> System.out.print(s+" ")); //4 1 6 5 2 3


//forEachOrdered()


Understanding Performance Improvements
Scaling is the property that, as we add more resources such as CPUs, the results gradually improve

Understanding Independent Operations

Arrays.asList("jackal","kangaroo","lemur")
   .parallelStream()
   .map(s -> s.toUpperCase())
   .forEach(System.out::println);

In this example, mapping jackal to JACKAL can be done independently of mapping kangaroo to KANGAROO. In other words, multiple elements of the stream can be processed at the same time and the results will not change.


Arrays.asList("jackal","kangaroo","lemur")
   .parallelStream()
   .map(s -> {System.out.println(s); return s.toUpperCase();})
   .forEach(System.out::println);


kangaroo
KANGAROO
lemur
jackal
JACKAL
LEMUR


>>Avoiding Stateful Operations

A stateful lambda expression is one whose result depends on any state that might change during
the execution of a pipeline.

A stateless lambda expression is one whose result does not depend on any state that might change during the execution of a pipeline.

List<Integer> data = Collections.synchronizedList(new ArrayList<>());
Arrays.asList(1,2,3,4,5,6)
   .parallelStream()
   .map(i -> {data.add(i); return i;}) // AVOID STATEFUL LAMBDA EXPRESSIONS!
   .forEachOrdered(i -> System.out.print(i + " "));
System.out.println();
for(Integer e: data) {
   System.out.print(e+" ");
}

The following is a sample generation of this code snippet using a parallel stream:
1 2 3 4 5 6
2 4 3 5 6 1


The forEachOrdered() method displays the numbers in the stream sequentially, whereas the
order of the elements in the data list is completely random. You can see that a stateful lambda
expression, which modifies the data list in parallel, produces unpredictable results at runtime.
Note that this would not have been noticeable with a serial stream, where the results
would have been the following:
1 2 3 4 5 6
1 2 3 4 5 6


>Processing Parallel Reductions

>>Performing Order-Based Tasks
Since order is not guaranteed with parallel streams, methods such as findAny() on parallel
streams may result in unexpected behavior

System.out.print(Arrays.asList(1,2,3,4,5,6).stream().findAny().get()); //1

System.out.print(Arrays.asList(1,2,3,4,5,6).parallelStream().findAny().get()); //any value in the stream

Any stream operation that is based on order, including findFirst(), limit(), or skip(), may actually perform more slowly in a parallel environment.

On the plus side, the results of ordered operations on a parallel stream will be consistent with a serial stream. For example, calling skip(5).limit(2).findFirst() will return the same result on ordered serial and parallel streams.


>>Combining Results with reduce()

The stream operation reduce() combines a stream into a single object.
Recall that first parameter to the reduce() method is called the identity, the second parameter is called the accumulator, and the third parameter is called the combiner.

System.out.println(Arrays.asList('w', 'o', 'l', 'f')
   .stream()
   .reduce("",(c,s1) -> c + s1, (s2,s3) -> s2 + s3));

Whereas with a serial stream, wolf was built one character at a time, in a parallel stream, the intermediate strings wo and lf could have been created and then combined.

Requirements for reduce() Arguments:

[] The identity must be defined such that for all elements in the stream u , 
combiner.apply(identity, u) is equal to u .
[] The accumulator operator op must be associative and stateless such that (a op b) op c
is equal to a op (b op c) .
[] The combiner operator must also be associative and stateless and compatible with the
identity, such that for all u and t combiner.apply(u,accumulator.apply(identity,t))
is equal to accumulator.apply(u,t) .

If you follow these principles when building your reduce() arguments, then the
operations can be performed using a parallel stream and the results will be ordered as they
would be with a serial stream.


Let’s take a look at an example using a non-associative accumulator.

System.out.println(Arrays.asList(1,2,3,4,5,6)
   .parallelStream()
   .reduce(0,(a,b) -> (a-b))); // NOT AN ASSOCIATIVE ACCUMULATOR


0 - 1 = -1
-1 -2 = -3
-3 -3 = -6
-4 -6 = -10
-10-5 = -15
-15-6 = -21

It may output -21, 3, or some other value, as the accumulator function violates the associativity property.

You can see other problems if we use an identity parameter that is not truly an identity value.

System.out.println(Arrays.asList("w","o","l","f")
   .parallelStream()
   .reduce("X",String::concat)); //s,a -> s.concat(a) XwXoXlXf



>>Combing Results with collect()

the Streams API includes a three-argument version of collect() that takes accumulator and combiner operators, along with a supplier operator instead of an identity.

Stream<String> stream = Stream.of("w", "o", "l", "f").parallel();
SortedSet<String> set = stream.collect(ConcurrentSkipListSet::new, Set::add, Set::addAll);
System.out.println(set); // [f, l, o, w]

You should use a concurrent collection to combine the results, ensuring that the results of concurrent threads do not cause a ConcurrentModificationException


>>Using the One-Argument collect() Method

Stream<String> stream = Stream.of("w", "o", "l", "f").parallel();
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]

The following rules ensure that a parallel reduction will be performed efficiently in Java using a collector.

Requirements for Parallel Reduction with collect()

[] The stream is parallel.
[] The parameter of the collect operation has the Collector.Characteristics.CONCURRENT
characteristic.
[] Either the stream is unordered, or the collector has the characteristic
Collector.Characteristics.UNORDERED.


Finally, we can rewrite our groupingBy() example from Chapter 4 to use a parallel
stream and parallel reduction:
Stream<String> ohMy = Stream.of("lions", "tigers", "bears").parallel();
ConcurrentMap<Integer, List<String>> map = ohMy.collect(
Collectors.groupingByConcurrent(String::length));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}

==================

=> Managing Concurrent Processes


>>Creating a CyclicBarrier

The CyclicBarrier takes in its constructors a limit value, indicating the number of threads to wait for;
CyclicBarrier c1 = new CyclicBarrier(4);

As each thread finishes, it calls the await() method on the cyclic barrier. Once the specified number
of threads have each called await(), the barrier is released and all threads can continue.
c1.await();

The await() method throws multiple checked exceptions.

we used two different constructors for our CyclicBarrier objects, the latter of which called a
Runnable method upon completion.

>>Thread Pool Size and Cyclic Barrier Limit

If you are using a thread pool, make sure that you set the number of available threads to be at least as large as your CyclicBarrier limit value. 

ExecutorService service = Executors.newFixedThreadPool(2);
CyclicBarrier c1 = new CyclicBarrier(4);


In this case, the code will hang indefinitely. The barrier would never be reached as the
only threads available in the pool are stuck waiting for the barrier to be complete. This is a form of deadlock.

>>Reusing CyclicBarrier
After a CyclicBarrier is broken, all threads are released and the number of threads waiting
on the CyclicBarrier goes back to zero. At this point, the CyclicBarrier may be
used again for a new set of waiting threads. For example, if our CyclicBarrier limit is 5
and we have 15 threads that call await(), then the CyclicBarrier will be activated a total
of three times.


>>Applying the Fork/Join Framework

Applying the fork/join framework requires us to perform three steps:
1. Create a ForkJoinTask.
2. Create the ForkJoinPool.
3. Start the ForkJoinTask.

For the exam, you should know how to implement the fork/join solution by extending one of two classes, RecursiveAction and RecursiveTask, both of which implement the ForkJoinTask interface.

The first class, RecursiveAction, is an abstract class that requires us to implement the compute() method, which returns void, to perform the bulk of the work. The second class, RecursiveTask, is an abstract generic class that requires us to implement the compute() method, which returns the generic type, to perform the bulk of the work


import java.util.*;
import java.util.concurrent.*;

public class WeighAnimalAction extends RecursiveAction {
   private int start;  
   private int end;
   private Double[] weights;

   public WeighAnimalAction(Double[] weights, int start, int end) {
      this.start = start;
      this.end = end;
      this.weights = weights;
   }

   protected void compute() {
      if(end-start <= 3)
         for(int i=start; i<end; i++) {
	    weights[i] = (double)new Random().nextInt(100);
	    System.out.println("Animal Weighed: "+i);
         }
      else {
         int middle = start+((end-start)/2); //5 > 2 > 2
         System.out.println("[start="+start+",middle="+middle+",end="+end+"]"); //0-5-10 > 0-2-5 > 5-7-10 
         invokeAll(new WeighAnimalAction(weights,start,middle), // 0-5 > 0-2 > 5-7
                   new WeighAnimalAction(weights,middle,end));  // 5-10 > 2-5 > 7-10
      }
   }
}


public static void main(String[] args) {
   Double[] weights = new Double[10];
   ForkJoinTask<?> task = new WeighAnimalAction(weights,0,weights.length); 
   ForkJoinPool pool = new ForkJoinPool();
   pool.invoke(task);
   // Print results
   System.out.println();
   System.out.print("Weights: ");
   Arrays.asList(weights).stream().forEach(d -> System.out.print(d.intValue()+" "));
}



>>Working with a RecursiveTask


import java.util.*;
import java.util.concurrent.*;

public class WeighAnimalAction extends RecursiveTask<Double> {
   private int start;  
   private int end;
   private Double[] weights;

   public WeighAnimalAction(Double[] weights, int start, int end) {
      this.start = start;
      this.end = end;
      this.weights = weights;
   }

   protected Double compute() {
      if(end-start <= 3){
         for(int i=start; i<end; i++) {
	    weights[i] = (double)new Random().nextInt(100);
	    System.out.println("Animal Weighed: "+i);
            sum += weights[i];
         }
         return sum; 
      }else {
         int middle = start+((end-start)/2); 
         System.out.println("[start="+start+",middle="+middle+",end="+end+"]");  
         
         RecursiveTask<Double> otherTask = new WeighAnimalTask(weights,start,middle);
         otherTask.fork();
	 return new WeighAnimalTask(weights,middle,end).compute() + otherTask.join();
           
      }
   }
}


public static void main(String[] args) {
   Double[] weights = new Double[10];
   
   ForkJoinTask<Double> task = new WeighAnimalTask(weights,0,weights.length);
   ForkJoinPool pool = new ForkJoinPool();
   Double sum = pool.invoke(task);   

   // Print results
   System.out.println("Sum: "+sum);
}



Since the invokeAll() method doesn’t return a value, we instead issue a fork() and join() command to retrieve the recursive data. The fork() method instructs the fork/join framework to complete the task in a separate thread, while the
join() method causes the current thread to wait for the results.

One thing to be careful about when using the fork() and join() methods is the order in which they are applied. For instance, while the previous example was multi-threaded, the following variation operates with single-threaded performance:

RecursiveTask<Double> otherTask = new WeighAnimalTask(weights,start,middle);
Double otherResult = otherTask.fork().join();
return new WeighAnimalTask(weights,middle,end).compute() + otherResult;

In this example, the current thread calls join(), causing it to wait for the [start,middle] subtask to finish before starting on the [middle,end] subtask
For the exam, make sure that fork() is called before the current thread begins a subtask and that join() is called after it finishes retrieving the results, in order for them to be done in parallel.


Identifying Fork/Join Issues
[] The class should extend RecursiveAction or RecursiveTask.
[] If the class extends RecursiveAction, then it should override a protected compute()
method that takes no arguments and returns void.
[] If the class extends RecursiveTask, then it should override a protected compute()
method that takes no arguments and returns a generic type listed in the class
definition.
[] The invokeAll() method takes two instances of the fork/join class and does not return
a result.
[] The fork() method causes a new task to be submitted to the pool and is similar to the
thread executor submit() method.
[] The join() method is called after the fork() method and causes the current thread to
wait for the results of a subtask.
[] Unlike fork(), calling compute() within a compute() method causes the task to wait
for the results of the subtask.
[] The fork() method should be called before the current thread performs a compute()
operation, with join() called to read the results afterward.
[] Since compute() takes no arguments, the constructor of the class is often used to pass
instructions to the task.


>>Identifying Threading Problems

>>Liveness
Liveness problems, then, are those in which the application becomes unresponsive or in
some kind of “stuck” state. For the exam, there are three types of liveness issues with
which you should be familiar: deadlock, starvation, and livelock.


>>Deadlock
Deadlock occurs when two or more threads are blocked forever, each waiting on the other

>>Starvation
Starvation occurs when a single thread is perpetually denied access to a shared resource
or lock.The thread is still active, but it is unable to complete its work as a result of other
threads constantly taking the resource that they trying to access.

>>Livelock
Livelock occurs when two or more threads are conceptually blocked forever, although they
are each still active and trying to complete their task.Livelock is often a result of two threads trying to resolve a deadlock.

>>Managing Race Conditions
For the exam, you should understand that race conditions lead to invalid data if they are
not properly handled. Even the solution where both participants fail to proceed is preferable
to one in which invalid data is permitted to enter the system.



==>>CAP9

>Understanding Files and Directories

java.io.File

the following is an absolute path to the zoo.txt file:
/home/smith/data/zoo.txt

The following is a relative path to the same file, assuming the user’s current directory
was set to /home/smith: 
data/zoo.txt


System.out.println(System.getProperty("file.separator"));
System.out.println(java.io.File.separator);


import java.io.File;
public class FileSample {
   public static void main(String[] args) {
      File file = new File("/home/smith/data/zoo.txt");
      System.out.println(file.exists());
   }
}


File parent = new File("/home/smith");
File child = new File(parent,"data/zoo.txt");


Method 			Name Description
===================	=========================================================================
exists() 		Returns true if the file or directory exists.

getName() 		Returns the name of the file or directory denoted by this path.

getAbsolutePath() 	Returns the absolute pathname string of this path.

isDirectory() 		Returns true if the file denoted by this path is a directory.

isFile() 		Returns true if the file denoted by this path is a file.

length() 		Returns the number of bytes in the file. For performance reasons, the
			file system may allocate more bytes on disk than the file actually uses.

lastModified() 		Returns the number of milliseconds since the epoch when the file
			was last modified.

delete() 		Deletes the file or directory. If this pathname denotes a directory,
			then the directory must be empty in order to be deleted.

renameTo(File) 		Renames the file denoted by this path.

mkdir() 		Creates the directory named by this path.

mkdirs() 		Creates the directory named by this path including any nonexistent
			parent directories.

getParent() 		Returns the abstract pathname of this abstract pathname’s parent
			or null if this pathname does not name a parent directory.

listFiles() 		Returns a File[] array denoting the files in the directory.



import java.io.File;
public class ReadFileInformation {
   public static void main(String[] args) {
      File file = new File("C:\\data\\zoo.txt");
      System.out.println("File Exists: "+file.exists());
      if(file.exists()) {
         System.out.println("Absolute Path: "+file.getAbsolutePath());
         System.out.println("Is Directory: "+file.isDirectory());
         System.out.println("Parent Path: "+file.getParent());
         if(file.isFile()) {
            System.out.println("File size: "+file.length());
            System.out.println("File LastModified: "+file.lastModified());
         } else {
            for(File subfile: file.listFiles()) {
               System.out.println("\t"+subfile.getName());
            }
         }
      }
   }
}


>>Introducing Streams

1. The stream classes are used for inputting and outputting all types of binary or byte
data.
2. The reader and writer classes are used for inputting and outputting only character and
String data.


>>Low-Level vs. High-Level Streams

A low-level stream connects directly with the source of the data, such as a file, an array,
or a String. Low-level streams process the raw data or resource and are accessed in a
direct and unfiltered manner.

a high-level stream is built on top of another stream using wrapping.
Wrapping is the process by which an instance is passed to the constructor of another
class and operations on the resulting instance are filtered and applied to the original
instance. For example, take a look at the FileWriter and BufferedWriter objects in the
following sample code:

try (BufferedReader bufferedReader = new BufferedReader(new FileReader("zoo-data.txt"))) {
	System.out.println(bufferedReader.readLine());
}


try (ObjectInputStream objectStream = 
     new ObjectInputStream(new BufferedInputStream(new FileInputStream("zoo-data.txt")))) {
     System.out.println(objectStream.readObject());
}


new BufferedInputStream(new FileReader("zoo-data.txt")); // DOES NOT COMPILE
new BufferedWriter(new FileOutputStream("zoo-data.txt")); // DOES NOT COMPILE
new ObjectInputStream(new FileOutputStream("zoo-data.txt")); // DOES NOT COMPILE
new BufferedInputStream(new InputStream()); // DOES NOT COMPILE

The first two examples do not compile because they mix Reader/Writer classes with
InputStream/OutputStream classes, respectively. The third example does not compile
because we are mixing an OutputStream with an InputStream. The last example does not compile because InputStream is an
abstract class, and therefore you cannot instantiate an instance of it.

[] A class with the word InputStream or OutputStream in its name is used for reading or
writing binary data, respectively.
[] A class with the word Reader or Writer in its name is used for reading or writing
character or string data, respectively.
[] Most, but not all, input classes have a corresponding output class.
[] A low-level stream connects directly with the source of the data.
[] A high-level stream is built on top of another stream using wrapping.
[] A class with Buffered in its name reads or writes data in groups of bytes or characters
and often improves performance in sequential file systems.



Class Name 		Low/High Level 		Description
===================	==================	==================================================================
InputStream 		N/A 			The abstract class all InputStream classes inherit from

OutputStream 		N/A 			The abstract class all OutputStream classes inherit from

Reader 			N/A 			The abstract class all Reader classes inherit from

Writer 			N/A 			The abstract class all Writer classes inherit from

FileInputStream 	Low 			Reads file data as bytes

FileOutputStream 	Low 			Writes file data as bytes

FileReader 		Low 			Reads file data as characters

FileWriter 		Low 			Writes file data as characters 

BufferedReader 		High 			Reads character data from an existing Reader in a buffered manner,
					 	which improves efficiency and performance

BufferedWriter 		High 			Writes character data to an existing Writer in a buffered manner, 
						which improves efficiency and performance

ObjectInputStream 	High 			Deserializes primitive Java data types and graphs of Java objects 
						from an existing InputStream

ObjectOutputStream 	High 			Serializes primitive Java data types and graphs of Java objects 
						to an existing OutputStream

InputStreamReader 	High 			Reads character data from an existing InputStream

OutputStreamWriter 	High 			Writes character data to an existing

PrintStream 		High 			Writes formatted representations of Java objects to a binary stream

PrintWriter 		High 			Writes formatted representations of Java objects to a text-based 
						output stream OutputStream

->> Common Stream Operations

>>Closing the Stream
Throughout this chapter, we will close stream resources using the try-with-resource syntax,
since this is the preferred way of closing resources in Java.

>>Flushing the Stream
In many operating systems, the data may be cached in memory, with a write occurring only after a temporary
cache is filled or after some amount of time has passed
Java provides a flush() method, which requests that all accumulated data be written immediately to disk.
You do not need to call the flush() method explicitly when you have finished writing
to a file, since the close() method will automatically do this.

>>Marking the Stream
The InputStream and Reader classes include mark(int) and reset() methods to move the stream back to an earlier position.
you should call the markSupported() method, which returns true only if mark() is supported.
on a class that does not support these operations will throw an exception at runtime.

Assume that we have an InputStream instance whose next values are ABCD:

InputStream is = . . .
System.out.print ((char)is.read()); //A
if(is.markSupported()) {
   is.mark(100); 
   System.out.print((char)is.read()); //B
   System.out.print((char)is.read()); //C
   is.reset();
}
System.out.print((char)is.read()); //B
System.out.print((char)is.read()); //C
System.out.print((char)is.read()); //D


>>Skipping over Data
The InputStream and Reader classes also include a skip(long) method.
It returns a long value, which indicates the number of bytes that were actually skipped. If the return value is zero or negative, such as if the end of the stream was reached, no bytes were skipped.

Assume that we have an InputStream instance whose next values are TIGERS.

InputStream is = . . .
System.out.print ((char)is.read()); //T
is.skip(2) 
is.read(); //(E)
System.out.print((char)is.read()); //R
System.out.print((char)is.read()); //S


->>Working with Streams

>>The FileInputStream and FileOutputStream Classes
The data in a FileInputStream object is commonly accessed by successive calls to the read() method until a value of -1 is returned, indicating that the end of the stream—in this case the end of the file.

The FileInputStream class also contains overloaded versions of the read() method, which take a pointer to a byte array where the data is written. The method returns an integer value indicating how many bytes can be read into the byte array

A FileOutputStream object is accessed by writing successive bytes using the write(int) method. Like the FileInputStream class, the FileOutputStream also contains overloaded versions of the write() method that allow a byte array to be passed and can be used by Buffered classes.

public static void copy(File source, File destination) throws IOException {
try (InputStream in = new FileInputStream(source);
     OutputStream out = new FileOutputStream(destination)) {
   int b;
   while((b = in.read()) != -1) {
      out.write(b);
   }
}
}

>>The BufferedInputStream and BufferedOutputStream Classes
Instead of reading the data one byte at a time, we use the underlying read(byte[]) method
of BufferedInputStream, which returns the number of bytes read into the provided byte
array. The number of bytes read is important for two reasons. First, if the value returned
is 0, then we know that we have reached the end of the file and can stop reading from the
BufferedInputStream. Second, the last read of the file will likely only partially fill the byte
array, since it is unlikely for the file size to be an exact multiple of our buffer array size

The data is written into the BufferedOutputStream using the write(byte[],int,int)
method, which takes as input a byte array, an offset, and a length value, respectively. The
offset value is the number of values to skip before writing characters, and it is often set to 0.

public static void copy(File source, File destination) throws IOException {
   try (InputStream in   = new BufferedInputStream(new FileInputStream(source));
        OutputStream out = new BufferedOutputStream(new FileOutputStream(destination))) {
   byte[] buffer = new byte[1024];
   int lengthRead;
   while ((lengthRead = in.read(buffer)) > 0) {
      out.write(buffer,0,lengthRead);
      out.flush();
   }
}

>>The FileReader and FileWriter classes
Like the FileInputStream and FileOutputStream classes, the FileReader and
FileWriter classes contain read() and write() methods, respectively. These methods
read/write char values instead of byte values; although similar to what you saw with
streams, the API actually uses an int value to hold the data so that -1 can be returned if
the end of the file is detected.

The Writer class, which FileWriter inherits from, offers a write(String) method that
allows a String object to be written directly to the stream. Using FileReader also allows
you to pair it with BufferedReader in order to use the very convenient readLine() method,
which you will see in the next example.



>>The BufferedReader and BufferedWriter Classes

public static List<String> readFile(File source) throws IOException {
   List<String> data = new ArrayList<String>();
   try (BufferedReader reader = new BufferedReader(new FileReader(source))) {
      String s;
      while((s = reader.readLine()) != null) {
         data.add(s);
      }
   }
   return data;
}


public static void writeFile(List<String> data, File destination) throws IOException {
   try (BufferedWriter writer = new BufferedWriter(new FileWriter(destination))) {
      for(String s: data) {
         writer.write(s);
         writer.newLine();
      }
   }
}

First, in the readFile() method, we use a temporary String
reference s to hold the value of the data in loop as we read it. Unlike FileInputStream
and FileReader, where we used -1 to check for file termination of an int value, with
BufferedReader, we stop reading the file when readLine() returns null.

Next, instead of immediately copying the data we read from the file into the output file,
we store it in a List of String objects in the readFile() method. This allows us to both
display and modify the data, prior to writing it to disk later.

The last major difference between this code and the previous copy file example is in
how data is written in the writeFile() method. Unlike the previous examples where we
had to write the code one byte at a time or by using a byte array, we can write the entire
String in a single call. The write(String) method is quite convenient in practice. We
then use the writer.newLine() method to insert a line break into the copied file, as our
reader.readLine() method split on line breaks.


>>The ObjectInputStream and ObjectOutputStream Classes
The process of converting an in-memory object to a stored data format is referred to as serialization , with the reciprocal process of converting stored data into an object, which is known as deserialization.

>>>The Serializable Interface
The Serializable interface is a marker interface, which means that it does not have any methods associated with it.

A process attempting to serialize an object will throw a NotSerializableException
if the class or one of its contained classes does not properly implement the Serializable
interface.

You can use the transient keyword on the reference to the object,
which will instruct the process serializing the object to skip it and avoid throwing a
NotSerializableException . The only limitation is that the data stored in the object will be
lost during the serialization process.

Besides transient instance variables, static class members will also be ignored during
the serialization and deserialization process.

public class Animal implements Serializable {
    private static final long serialVersionUID = 1L; //not required as part of implementing Serializable

If an older version of the class is encountered during deserialization, an exception may be thrown.

>>>Serializing and Deserializing Objects

The ObjectOutputStream class includes a method to serialize the object to the stream
called void writeObject(Object). If the provided object is not Serializable, or
it contains an embedded reference to a class that is not Serializable or not marked
transient, a NotSerializableException will be thrown at runtime.

the ObjectInputStream class includes a deserialization
method that returns an object called readObject(). Notice that the return type of this
method is the generic type java.lang.Object, indicating that the object will have to be cast
explicitly at runtime to be used.


public static void createAnimalsFile(List<Animal> animals, File dataFile) throws IOException {
   try (ObjectOutputStream out = new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(dataFile)))) {
   for(Animal animal: animals)
       out.writeObject(animal);
   }
}

public static List<Animal> getAnimals(File dataFile) throws IOException, ClassNotFoundException {
    List<Animal> animals = new ArrayList<Animal>();
    try (ObjectInputStream in = new ObjectInputStream(new BufferedInputStream(new FileInputStream(dataFile)))) {
        while(true) {
           Object object = in.readObject();
           if(object instanceof Animal)
              animals.add((Animal)object);
       }
    } catch (EOFException e) {
        // File end reached
    }
    return animals;
}



[Animal [name=Tommy Tiger, age=5, type=T], Animal [name=Peter Penguin, age=8,type=P]]


The readObject() throws the checked exception, ClassNotFoundException, since the class of the deserialized object may not be available to the JRE.

Finally, since we are reading objects, we can’t use a -1 integer value to determine when
we have finished reading a file. Instead, the proper technique is to catch an EOFException,
which marks the program encountering the end of the file. Notice that we don’t do anything
with the exception other than finish the method. This is one of the few times when it
is perfectly acceptable to swallow an exception.

>>>Understanding Object Creation

For the exam, you need be aware of how a deserialized object is created. When you deserialize
an object, the constructor of the serialized class is not called. In fact, Java calls the first
no-arg constructor for the first nonserializable parent class, skipping the constructors of
any serialized class in between. Furthermore, any static variables or default initializations
are ignored.

public class Animal implements Serializable {
   private static final long serialVersionUID = 2L;
   private transient String name;
   private transient int age = 10;
   private static char type = 'C';

   {this.age = 14;}

   public Animal() {
      this.name = "Unknown";
      this.age = 12;
      this.type = 'Q';
   }

   public Animal(String name, int age, char type) {
     this.name = name;
     this.age = age;
     this.type = type;
   }
   
   // Same methods as before
   . . .
}


As we said earlier, transient means the value won’t be included in the serialization
process, so it’s safe to assume name and age will be left out of the serialized file. More
interestingly, the values of age being set to 10, 12, or 14 in the class are all ignored when
the object is deserialized, as no class constructor or default initializations are used. The
following is the output of the ObjectStreamSample program with the new Animal class
definition:

[Animal [name=null, age=0, type=P], Animal [name=null, age=0, type=P]]

As expected, you can see that the values for name and age are lost on serialization and
not set again during deserialization. The JVM initializes these variables with the default
values based on the data types String and int, which are null and 0, respectively. Since
the type variable is static, it is not serialized to disk. The sample program displays a value
for type, as the variable is shared by all instances of the class and is the last value in our
sample program.


>> The PrintStream and PrintWriter Classes

The PrintStream class operates on OutputStream instances and writes data as bytes, whereas the PrintWriter class operates on Writer instances and writes data as characters.
For convenience, both of these classes include constructors that can open and write
to files directly. Furthermore, the PrintWriter class even has a constructor that takes an
OutputStream as input, allowing you to wrap a PrintWriter class around an OutputStream.


These classes are primarily convenience classes in that you could write the low-level
primitive or object directly to a stream without a PrintStream or PrintWriter class,
although using one is helpful in a wide variety of situations.

For the exam, you should be aware that System.out and System.err are actually PrintStream objects

Because PrintStream inherits OutputStream and PrintWriter inherits from Writer ,
both support the underlying write() method while providing a slew of print-based
methods.

Unlike the underlying write() method, which throws a checked
IOException that must be caught in your application, these print-based methods do
not throw any checked exceptions

>>>print()
In general, these methods perform String.valueOf() on the argument and call the underlying stream’s write() method

PrintWriter out = new PrintWriter("zoo.log");
out.print(5); // PrintWriter method
out.write(String.valueOf(5)); // Writer method
out.print(2.0); // PrintWriter method
out.write(String.valueOf(2.0)); // Writer method
Animal animal = new Animal();
out.print(animal); // PrintWriter method
out.write(animal==null ? "null": animal.toString()); // Writer method

You may remember from your OCA study material that valueOf() applied to an object
calls the object’s toString() method or returns null if the object is not set.


>>>println()

>>>format() and printf()
public PrintWriter format(String format, Object args. . .)
public PrintWriter printf(String format, Object args. . .)


>>Sample PrintWriter Application

import java.io.*;
public class PrintWriterSample {
   public static void main(String[] args) throws IOException {
      File source = new File("zoo.log");  
      try (PrintWriter out = new PrintWriter(new BufferedWriter(new FileWriter(source)))) {
         out.print("Today's weather is: ");
         out.println("Sunny");
         out.print("Today's temperature at the zoo is: ");
         out.print(1/3.0);
         out.println('C');
         out.format("It has rained 10.12 inches this year");
         out.println();
         out.printf("It may rain 21.2 more inches this year");
     }
   }
}


>>Review of Stream Classes

-InputStream
|--FileInputStream[Low]
|--ObjectInputStream
|--FilterInputStream[OUT OF SCOPE]
  |--BufferedInputStream

-Reader
|--BufferedReader
|--InputStreamReader[OUT OF SCOPE] 
  |--FileReader[Low] 

-OutputStream
|--FileOutputStream[Low]
|--ObjectOutputStream
|--FilterOutputStream[OUT OF SCOPE]
  |--BufferedOutputStream
  |--PrintStream

-Writer
|--BufferedWriter
|--PrintWriter
|--OutputStreamWriter[OUT OF SCOPE]
  |--FileWriter[LOW]



->>Interacting with Users  

>>The Old Way

import java.io.*;
public class SystemInSample {
   public static void main(String[] args) throws IOException {
      BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));
      String userInput = reader.readLine();
      System.out.println("You entered the following: "+userInput);
   }
}


>>The New Way

import java.io.Console;
public class ConsoleSample {
   public static void main(String[] args) {
      Console console = System.console();
      if(console != null) {
         String userInput = console.readLine();
         console.writer().println ("You entered the following: "+userInput);
      }
   }
}


The sample code first retrieves an instance of the Console singleton and determines
if the Console is available by checking it for a null value. If the Console is available, it
then retrieves a line of input from the user using the readLine() method, and it outputs
the result using the Console’s built-in PrintWriter object, accessed via the writer()
method.

We will now review the various methods available in the Console class: 

-reader() and writer()
The Console class provides access to an instance of Reader and PrintWriter using the
methods reader() and writer(), respectively.

-format() and printf()
Note that the Console class defines only one format() method, and it does not define a
format() method that takes a locale variable:

Console console = System.console();
console.writer().format(new Locale("fr", "CA"),"Hello World"); 

-flush()

-readLine()
The basic readLine() method retrieves a single line of text from the user, and the user
presses the Enter key to terminate it.

String excitementAnswer = console

.readLine();
String name = console.readLine(“Please enter your name: “);

BufferedReader reader = new BufferedReader(console.reader());
String value = reader.readLine();


-readPassword()
The readPassword() method is similar to the readLine() method, except that echoing is
disabled.
the readLine() method, though, the readPassword() method returns an array of characters
instead of a String.


==>>cap 9 NIO2

Path is a direct replacement for the legacy java.io.File class.
Unlike the File class, the Path interface contains support for symbolic links. 

>>Creating Instances with Factory and Helper Classes

NIO.2 also includes helper classes such as java.nio.file.Files, whose primary purpose
is to operate on instances of Path objects.

>>Creating Paths
>>>Using the Paths Class

Path path1 = Paths.get("pandas/cuddly.png");
Path path2 = Paths.get("c:\\zooinfo\\November\\employees.txt");
Path path3 = Paths.get("/home/zoodirector");

You can also create a Path using the Paths class using a vararg of type String, such as
Paths.get(String,String...)

Path path1 = Paths.get("pandas","cuddly.png");
Path path2 = Paths.get("c:","zooinfo","November","employees.txt");
Path path3 = Paths.get("/","home","zoodirector");


Path path1 = Paths.get(new URI("file://pandas/cuddly.png")); // THROWS EXCEPTION
// AT RUNTIME
Path path2 = Paths.get(new URI("file:///c:/zoo-info/November/employees.txt"));
Path path3 = Paths.get(new URI("file:///home/zoodirectory"));

The first example actually throws an exception at runtime, as URIs must reference absolute paths at runtime. The URI class does have an isAbsolute() method

Note that the constructor new URI(String) does throw a checked URISyntaxException,
which would have to be caught in any application where the previous code snippets are used.

the Path interface also contains a reciprocal method toUri() for converting a
Path instance back to a URI instance, as shown in the following sample code:

Path path4 = Paths.get(new URI("http://www.wiley.com"));
URI uri4 = path4.toUri();


>>>Accessing the Underlying FileSystem Object

Path path1 = FileSystems.getDefault().getPath("pandas/cuddly.png");

Path path2 = FileSystems.getDefault().getPath("c:","zooinfo","November","employees.txt");

Path path3 = FileSystems.getDefault().getPath("/home/zoodirector");

the FileSystems factory class does give us the ability to connect to a remote file system, as
shown in the following sample code:

FileSystem fileSystem = FileSystems.getFileSystem(new URI("http://www.selikoff.net"));
Path path = fileSystem.getPath("duck.txt");

>>>Working with Legacy File Instances

File file = new File("pandas/cuddly.png");
Path path = file.toPath();

Path path = Paths.get("cuddly.png");
File file = path.toFile();

>>Interacting with Paths and Files

Enum Value 		Usage 		    	Description
====================	=====================  	===================================================
NOFOLLOW_LINKS		Test file existing  	If provided, symbolic links when encountered	
			Read file data	    	will not be traversed. Useful for performing	
			Copy file	    	operations on symbolic links themselves rather	
			Move file           	than their target.

FOLLOW_LINKS 		Traverse a directory	If provided, symbolic links when encountered
			tree			will be traversed.

COPY_ATTRIBUTES		Copy file		If provided, all metadata about a file will be
						copied with it.

REPLACE_EXISTING 	Copy file		If provided and the target file exists, it will
			Move file		be replaced; otherwise, if it is not provided,
						an exception will be thrown if the file already
						exists.

ATOMIC_MOVE		Move file		The operation is performed in an atomic manner
						within the file system, ensuring that any process
						using the file sees only a complete record. 
						Method using it may throw an exception if the 
						feature is unsupported by the file system.
						(AtomicMoveNotSupportedException)


Paths.get("/zoo/../home").getParent().normalize().toAbsolutePath();


>>>Viewing the Path with toString(), getNameCount(), and getName()

Path path = Paths.get("/land/hippo/harry.happy");
System.out.println("The Path Name is: "+path);

for(int i=0; i < path.getNameCount(); i++) {
   System.out.println(" Element " + i + " is: " + path.getName(i));
}

For greater compatibility with other NIO.2 methods, the
getName(int) method returns the component of the Path as a new Path object rather
than a String.

As you might remember from our discussion of PrintStream/PrintWriter in Chapter 8,
printing an object automatically invokes the object’s toString() method.

The Path Name is: /land/hippo/harry.happy
  Element 0 is: land
  Element 1 is: hippo
  Element 2 is: harry.happy

Notice that the root element / is not included in the list of names. If the Path object
represents the root element itself, then the number of names in the Path object returned by
getNameCount() will be 0.


relative path:
The Path Name is: land/hippo/harry.happy
Element 0 is: land
Element 1 is: hippo
Element 2 is: harry.happy


>>>Accessing Path Components with getFileName(), getParent(), and getRoot()

getFileName(), returns a Path instance representing the filename, which is the farthest element from the root.

getParent(), returns a Path instance representing the parent path or null if there is no such parent.

getRoot(), returns the root element for the Path object or null if the Path object is relative.


import java.nio.file.*;
public class PathFilePathTest {
   
   public static void printPathInformation(Path path) {
      System.out.println("Filename is: " + path.getFileName() );
      System.out.println("Root is: "+ path.getRoot() );
      Path currentParent = path;
      while((currentParent = currentParent.getParent()) != null) {
         System.out.println(" Current parent is: "+currentParent);
      }
   }
   
   public static void main(String[] args) {
      printPathInformation(Paths.get("/zoo/armadillo/shells.txt"));
      System.out.println();
      printPathInformation(Paths.get("armadillo/shells.txt"));  
   }
}


>/zoo/armadillo/shells.txt

Filename is: shells.txt
Root is: /
Current parent is: /zoo/armadillo
Current parent is: /zoo
Current parent is: /



armadillo/shells.txt

Filename is: shells.txt
Root is: null
Current parent is: armadillo



>>Checking Path Type with isAbsolute() and toAbsolutePath()

isAbsolute(), returns true if the path the object references is absolute and false if the path the object references is relative.

toAbsolutePath(), converts a relative Path object to an absolute Path object by joining it to the current working directory. If the Path object is already absolute, then the method just returns an equivalent copy of it.

current working directory of /home.

Path path1 = Paths.get("C:\\birds\\egret.txt");
System.out.println("Path1 is Absolute? "+path1.isAbsolute()); //true
System.out.println("Absolute Path1: "+path1.toAbsolutePath()); //C:\birds\egret.txt 

Path path2 = Paths.get("birds/condor.txt"); 
System.out.println("Path2 is Absolute? "+path2.isAbsolute()); //false
System.out.println("Absolute Path2 "+path2.toAbsolutePath()); // /home/birds/condor.txt 

Keep in mind that if the Path object already represents an absolute path, then the output
is a new Path object with the same value.


>>Creating a New Path with subpath()
subpath(int,int) returns a relative subpath of the Path object, referenced by an inclusive start index and an exclusive end index.

Path path = Paths.get("/mammal/carnivore/raccoon.image");
System.out.println("Path is: " + path); 

System.out.println("Subpath from 0 to 3 is: "+path.subpath(0,3)); mammal/carnivore/raccoon.image
System.out.println("Subpath from 1 to 3 is: "+path.subpath(1,3)); carnivore/raccoon.image
System.out.println("Subpath from 1 to 2 is: "+path.subpath(1,2)); carnivore
 
 
This code demonstrates that the subpath(int,int) method does not include the root
of the file

System.out.println("Subpath from 0 to 4 is: "+path.subpath(0,4)); // THROWS EXCEPTION AT RUNTIME

System.out.println("Subpath from 1 to 1 is: "+path.subpath(1,1)); // THROWS EXCEPTION AT RUNTIME



>>Using Path Symbols

Symbol Description
.      A reference to the current directory
..     A reference to the parent of the current directory



>>Deriving a Path with relativize()

Path path1 = Paths.get("fish.txt");
Path path2 = Paths.get("birds.txt");             

System.out.println(path1.relativize(path2));
System.out.println(path2.relativize(path1));

The code snippet produces the following output when executed:
..\birds.txt
..\fish.txt


Alternatively, if both path values are absolute, then the method computes the relative
path from one absolute location to another, regardless of the current working directory.

Path path3 = Paths.get("E:\\habitat");           // ..\sanctuary\raven
Path path4 = Paths.get("E:\\sanctuary\\raven");  // ..\..\habitat

System.out.println(path3.relativize(path4));
System.out.println(path4.relativize(path3));

the root path element E: may not exist in the file system, yet the code would execute without issue
since Java is referencing the path elements and not the actual file values.


The relativize() method requires that both paths be absolute or both relative, and
it will throw an IllegalArgumentException if a relative path value is mixed with an
absolute path value

Path path1 = Paths.get("/primate/chimpanzee");
Path path2 = Paths.get("bananas.txt");
Path1.relativize(path3); // THROWS EXCEPTION AT RUNTIME IllegalArgumentException

On Windows-based systems, it also requires that if absolute paths are used, then both
paths must have the same root directory or drive letter.

Path path3 = Paths.get("c:\\primate\\chimpanzee");
Path path4 = Paths.get("d:\\storage\\bananas.txt");
path3.relativize(path4); // THROWS EXCEPTION AT RUNTIME IllegalArgumentException


>>Joining Path Objects with resolve()

resolve(Path) method for creating a new Path by joining an existing path to the current path.

final Path path1 = Paths.get("/cats/../panther");
final Path path2 = Paths.get("food");
System.out.println(path1.resolve(path2));

The code snippet generates the following output:
/cats/../panther/food

the resolve() method does not clean up path symbols, such as the parent directory .. symbol. For that,
you’ll need to use the normalize() method, which we will cover next.


In this example, the input argument to the resolve() method was a relative path, but
what if had been an absolute path?
final Path path1 = Paths.get("/turkey/food");
final Path path2 = Paths.get("/tiger/cage");
System.out.println(path1.resolve(path2));

Since the input parameter path2 is an absolute path, the output would be the following:
/tiger/cage


>>Cleaning Up a Path with normalize()

Path path3 = Paths.get("E:\\data");
Path path4 = Paths.get("E:\\user\\home");

Path relativePath = path3.relativize(path4); //  ..\user\home 
System.out.println(path3.resolve(relativePath)); E:\data\..\user\home 

System.out.println(path3.resolve(relativePath).normalize()); E:\user\home



>>Checking for File Existence with toRealPath()

The toRealPath(Path) method takes a Path object that may or may not point to an
existing file within the file system, and it returns a reference to a real path within the file
system.

It is similar to the toAbsolutePath() method in that it can convert a relative path
to an absolute path, except that it also verifies that the file referenced by the path actually
exists, and thus it throws a checked IOException at runtime if the file cannot be located. It
is also the only Path method to support the NOFOLLOW_LINKS option.

The toRealPath() method performs additional steps, such as removing redundant path
elements. In other words, it implicitly calls normalize() on the resulting absolute path.


Symbolic link:
/zebra/food.source ? /horse/food.txt

current working directory is /horse/schedule: 

try {
   System.out.println(Paths.get("/zebra/food.source").toRealPath());  // /horse/food.txt
   System.out.println(Paths.get(".././food.txt").toRealPath()); //    // /horse/food.txt    
} catch (IOException e) {
   // Handle file I/O exception...
}


We can also use the toRealPath() method to gain access to the current working
directory, such as shown here:

System.out.println(Paths.get(".").toRealPath());


>>Interacting with Files

many of the same operations available in java.io.File are available to java.nio.file.Path via a helper
class called java.nio.file.Files , or Files for short.

most of the options within the Files class will throw an exception if the fi le to
which the Path refers does not exist.

Keep in mind that File belongs to the legacy java.io API, while Files belongs to the NIO.2 API.

>>Testing a Path with exists()
Files.exists(Path) method takes a Path object and returns true if, and only if, it
references a fi le that exists in the fi le system.

Files.exists(Paths.get("/ostrich/feathers.png"));
Files.exists(Paths.get("/ostrich"));


>>Testing Uniqueness with isSameFile()

The Files.isSameFile(Path,Path) method is useful for determining if two Path objects
relate to the same fi le within the fi le system. It takes two Path objects as input and follows
symbolic links. Despite the name, the method also determines if two Path objects refer to
the same directory.

The isSameFile() method fi rst checks if the Path objects are equal in terms of equal() ,
and if so, it automatically returns true without checking to see if either fi le exists. If the
Path object equals() comparison returns false , then it locates each fi le to which the
path refers in the fi le system and determines if they are the same, throwing a checked
IOException if either fi le does not exist.

Let’s assume that all of the files in the following examples exist within the file system and
that cobra is a symbolic link to the snake file.


try {
   System.out.println(Files.isSameFile(Paths.get("/user/home/cobra"),
   Paths.get("/user/home/snake"))); //true
   
   System.out.println(Files.isSameFile(Paths.get("/user/tree/../monkey"),
   Paths.get("/user/monkey"))); //true
   
   System.out.println(Files.isSameFile(Paths.get("/leaves/./giraffe.exe"),
   Paths.get("/leaves/giraffe.exe"))); //true
   
   System.out.println(Files.isSameFile(Paths.get("/flamingo/tail.data"),
   Paths.get("/cardinal/tail.data")));  //false

} catch (IOException e) {
   // Handle file I/O exception...
}


>>Making Directories with createDirectory() and createDirectories()

The directory-creation methods can throw the checked IOException, such as when the directory cannot be created or already exists.

Both of these methods also accept an optional list of FileAttribute<?> values to set on
the newly created directory or directories.

try {
   Files.createDirectory(Paths.get("/bison/field"));
   Files.createDirectories(Paths.get("/bison/field/pasture/green"));
} catch (IOException e) {
   // Handle file I/O exception...
}

The first example creates a new directory, field, in the directory /bison, assuming
/bison exists; or else an exception is thrown.

Contrast this with the second example that creates the directory green along with any of the following parent directories if they do not already exist, such as /bison, /bison/field, or /bison/pasture.


>>Duplicating File Contents with copy()

Files.copy(Path,Path)
The copy() method throws the checked IOException, such as when the file or directory does not exist or cannot be read.

Directory copies are shallow rather than deep, meaning that files and subdirectories
within the directory are not copied.

try {
   Files.copy(Paths.get("/panda"), Paths.get("/panda-save"));
   Files.copy(Paths.get("/panda/bamboo.txt"),Paths.get("/panda-save/bamboo.txt"));
} catch (IOException e) {
   // Handle file I/O exception...
}

The first example performs a shallow copy of the panda directory, creating a new
panda-save directory

These behaviors can be altered by providing the additional options NOFOLLOW_LINKS,
REPLACE_EXISTING, and COPY_ATTRIBUTES, respectively, as discussed earlier in the chapter.


>>Copying Files with java.io and NIO.2

The first copy() method takes a source java.io.InputStream along with a target Path object. It reads the contents from the stream and writes the output to a file represented by a Path object.

The second copy() method takes a source Path object and target java.io.OutputStream.
It reads the contents of the file and writes the output to the stream.


try (InputStream is = new FileInputStream("source-data.txt");
     OutputStream out = new FileOutputStream("output-data.txt")) {
   // Copy stream data to file
   Files.copy(is, Paths.get("c:\\mammals\\wolf.txt"));
   // Copy file data to stream
   Files.copy(Paths.get("c:\\fish\\clown.xsl"), out);
} catch (IOException e) {
   // Handle file I/O exception...
}

Like the first copy() method, the copy(InputStream,Path) method also supports
optional vararg options, since the data is being written to a file represented by a Path
object. The second method, copy(Path,OutputStream), does not support optional vararg
values, though, since the data is being written to a stream that may not represent a file
system resource.


>>Changing a File Location with move()

The Files.move(Path,Path) method moves or renames a file or directory within the fi le
system. Like the copy() method, the move() method also throws the checked IOException
in the event that the fi le or directory could not be found or moved.

try {
   Files.move(Paths.get("c:\\zoo"), Paths.get("c:\\zoo-new"));
   Files.move(Paths.get("c:\\user\\addresses.txt"),Paths.get("c:\\zoo-new\\addresses.txt"));
} catch (IOException e) {
   // Handle file I/O exception...
}

These behaviors can be changed by providing the optional values NOFOLLOW_LINKS , REPLACE_EXISTING , or ATOMIC_MOVE.

********** The Files.move() method can be applied to non-empty directories only if
they are on the same underlying drive. While moving an empty directory
across a drive is supported, moving a non-empty directory across a drive
will throw an NIO.2 DirectoryNotEmptyException . ***************


>>Removing a File with delete() and deleteIfExists()

The Files.delete(Path) method deletes a file or empty directory within the file system.

For example, if the path represents a non-empty directory, the operation will throw the
runtime DirectoryNotEmptyException . If the target of the path is a symbol link, then the
symbolic link will be deleted, not the target of the link.

The deleteIfExists(Path) method is identical to the delete(Path) method, except
that it will not throw an exception if the fi le or directory does not exist, but instead it will
return a boolean value of false . It will still throw an exception if the file or directory does
exist but fails, such as in the case of the directory not being empty.

try {
   Files.delete(Paths.get("/vulture/feathers.txt"));
   Files.deleteIfExists(Paths.get("/pigeon"));
} catch (IOException e) {
   // Handle file I/O exception...
}

The first example deletes the features.txt file in the vulture directory, and it throws
a NoSuchFileException if the file or directory does not exist. The second example deletes
the pigeon directory assuming it is empty. If the pigeon directory does not exist, then the
second line will not throw an exception.


>>Reading and Writing File Data with newBufferedReader() and newBufferedWriter()


Files.newBufferedReader(Path,Charset), reads the file specified
at the Path location using a java.io.BufferedReader object. It also requires a Charset
value to determine what character encoding to use to read the file.

Path path = Paths.get("/animals/gopher.txt");
try (BufferedReader reader = Files.newBufferedReader(path,Charset.forName("US-ASCII"))) {
   // Read from the stream
   String currentLine = null;
   while((currentLine = reader.readLine()) != null)
       System.out.println(currentLine);
} catch (IOException e) {
   // Handle file I/O exception...
}


The second method, Files.newBufferedWriter(Path,Charset), writes to a file specified
at the Path location using a BufferedWriter

Path path = Paths.get("/animals/gorilla.txt");
List<String> data = new ArrayList();
try (BufferedWriter writer = Files.newBufferedWriter(path,Charset.forName("UTF-16"))) {
   writer.write("Hello World");
} catch (IOException e) {
   // Handle file I/O exception...
}


>>Reading Files with readAllLines()

The Files.readAllLines() method reads all of the lines of a text file and returns the
results as an ordered List of String values

Path path = Paths.get("/fish/sharks.log");
try {
   final List<String> lines = Files.readAllLines(path);
   for(String line: lines) {
      System.out.println(line);
   }
} catch (IOException e) {
   // Handle file I/O exception...
}

As you might expect, the method may throw an IOException if the file cannot be read.


>>Understanding File Attributes

>>>Reading Common Attributes with isDirectory(), isRegularFile(), and isSymbolicLink()

Files.isDirectory(Path)
Files.isRegularFile(Path) 
Files.isSymbolicLink(Path)

it is possible for isRegularFile() to return true for a symbolic link, as long as the link resolves to a regular file.
Files.isDirectory(Paths.get("/canine/coyote/fur.jpg"));
Files.isRegularFile(Paths.get("/canine/types.txt"));
Files.isSymbolicLink(Paths.get("/canine/coyote"));


The first example returns true if fur.jpg is a directory or a symbolic link to a directory
and false otherwise.Note that directories can have extensions in many file systems, so it
is possible for fur.jpg to be the name of a directory.

You may notice when browsing the Files API that isDirectory(), isRegularFile(), and
isSymbolicLink() do not throw an exception if the path does not exist,


>>Checking File Visibility with isHidden()
try {
   System.out.println(Files.isHidden(Paths.get("/walrus.txt")));
} catch (IOException e) {
   // Handle file I/O exception...
}

If the walrus.txt file is available and hidden within the file system, this method will
return true.
The isHidden() method throws the checked IOException, as there may be an I/O error reading the underlying file information.


>>Testing File Accessibility with isReadable() and isExecutable()

System.out.println(Files.isReadable(Paths.get("/seal/baby.png")));
System.out.println(Files.isExecutable(Paths.get("/seal/baby.png")));

Like the isDirectory(), isRegularFile(), and isSymbolicLink() methods, the isReadable() and isExecutable() methods do not throw exceptions if the file does not exist but instead return false.

>>Reading File Length with size()

The Files.size(Path) method is used to determine the size of the fi le in bytes.
The size() method throws the checked IOException if the fi le does not exist or if
the process is unable to read the file information.

try {
   System.out.println(Files.size(Paths.get("/zoo/c/animals.txt")));
} catch (IOException e) {
   // Handle file I/O exception...
}

The Files.size() method is defined only on files. Calling Files.size() on a directory is system dependent and undefined.

>>Managing File Modifications with getLastModifiedTime() and setLastModifiedTime()

The Files class provides the method Files.getLastModifiedTime(Path) , which returns
a FileTime object to accomplish this. The FileTime class is a simple container class that
stores the date/time information about when a fi le was accessed, modifi ed, or created. For
convenience, it has a toMillis() method that returns the epoch time.

The Files class also provides a mechanism for updating the last-modifi ed date/time of
a fi le using the Files.setLastModifiedTime(Path,FileTime) method. The FileTime class
also has a static fromMillis() method that converts from the epoch time to a FileTime
object.


try {
   final Path path = Paths.get("/rabbit/food.jpg");
   System.out.println(Files.getLastModifiedTime(path).toMillis());
   Files.setLastModifiedTime(path, FileTime.fromMillis(System.currentTimeMillis()));
   System.out.println(Files.getLastModifiedTime(path).toMillis());
} catch (IOException e) {
   // Handle file I/O exception...
}


>>Managing Ownership with getOwner() and setOwner()
Files.getOwner(Path)
Files.setOwner(Path,UserPrincipal)

Both the getOwner() and setOwner() methods can throw the checked exception IOException in
case of any issues accessing or modifying the fi le.

In order to set a fi le owner to an arbitrary user, the NIO.2 API provides a UserPrincipalLookupService helper class for fi nding a UserPrincipal.

UserPrincipal owner = FileSystems.getDefault()
                                 .getUserPrincipalLookupService()
                                 .lookupPrincipalByName("jane");

UserPrincipal owner = path.getFileSystem()
                          .getUserPrincipalLookupService()
                          .lookupPrincipalByName("jane");


try {
   // Read owner of file
   Path path = Paths.get("/chicken/feathers.txt");
   System.out.println(Files.getOwner(path).getName());
   
   // Change owner of file
   UserPrincipal owner = path.getFileSystem()
                             .getUserPrincipalLookupService()
                             .lookupPrincipalByName("jane");
   Files.setOwner(path, owner);
   
   // Output the updated owner information
   System.out.println(Files.getOwner(path).getName());
} catch (IOException e) {
   // Handle file I/O exception...
}


>>Improving Access with Views

A view is a group of related attributes for a particular file system type.


>>Understanding Views
To request a view, you need to provide both a path to the file or a directory whose information
you want to read, as well as a class object, which tells the NIO.2 API method which
type of view you would like returned.

Attributes Class 	View Class 		Description
=====================	=======================	===============================================
BasicFileAttributes 	BasicFileAttributeView	Basic set of attributes supported by all 
                                                file systems

>>Reading Attributes	

The NIO.2 API provides a Files.readAttributes(Path,Class<A>) method, which returns
read-only versions of a file view. The second parameter uses generics such that the return
type of the method will be an instance of the provided class.



>>BasicFileAttributes

All attributes classes extend from BasicFileAttributes; therefore it contains attributes
common to all supported file systems. It includes many of the file attributes that you previously
saw as single-line method calls in the Files class, such as Files.isDirectory(),
Files.getLastModifiedTime(), and so on.
We now present a sample application that retrieves BasicFileAttributes on a file and
outputs various metadata about the file:

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.BasicFileAttributes;

public class BasicFileAttributesSample {
   public static void main(String[] args) throws IOException {
	Path path = Paths.get("/turtles/sea.txt");
	BasicFileAttributes data = Files.readAttributes(path,BasicFileAttributes.class);
	System.out.println("Is path a directory? "+data.isDirectory());
	System.out.println("Is path a regular file? "+data.isRegularFile());
	System.out.println("Is path a symbolic link? "+data.isSymbolicLink());
	System.out.println("Path not a file, directory, nor symbolic link? "+ data.isOther());
	System.out.println("Size (in bytes): "+data.size());
	System.out.println("Creation date/time: "+data.creationTime());
	System.out.println("Last modified date/time: "+data.lastModifiedTime());
	System.out.println("Last accessed date/time: "+data.lastAccessTime());
	System.out.println("Unique file identifier (if available): "+ data.fileKey());
   }
}


The only ones that are new are isOther(), lastAccessTime(),
creationTime(), and fileKey(). The isOther() method is used to check for paths that are not
files, directories, or symbolic links, such as paths that refer to resources or devices in some file
systems. The lastAccessTime() and creationTime() methods return other date/time information
about the file. The fileKey() method returns a file system value that represents a unique
identifier for the file within the file system or null if it is not supported by the file system.


>>Modifying Attributes
The NIO.2 API provides the Files.getFileAttributeView(Path,Class<V>) method, which returns a view object that we can use to update the file system–dependent attributes. We can also use the view object
to read the associated file system attributes by calling readAttributes() on the view object.

>>BasicFileAttributeView
BasicFileAttributeView is used to modify a file’s set of date/time values. In general, we
cannot modify the other basic attributes directly, since this would change the property of
the file system object.

import java.io.IOException;
import java.nio.file.*;
import java.nio.file.attribute.*;

public class BasicFileAttributeViewSample {
   public static void main(String[] args) throws IOException {
	Path path = Paths.get("/turtles/sea.txt");
	BasicFileAttributeView view = Files.getFileAttributeView(path,BasicFileAttributeView.class);
	BasicFileAttributes data = view.readAttributes();

	FileTime lastModifiedTime = FileTime.fromMillis(data.lastModifiedTime().toMillis()+10_000);
	view.setTimes(lastModifiedTime,null,null);
   }
}

Since there is only one update method, setTimes(FileTime lastModifiedTime, FileTime
lastAccessTime, FileTime createTime) in the BasicFileAttributeView class, and it
takes three arguments, we need to pass three values to the method.
The NIO.2 API allows us to pass null for any date/time value that we do not wish to
modify. For example, the following line of code would change only the last-modified
date/time, leaving the other file date/time values unaffected:
view.setTimes(lastModifiedTime,null,null);


=>>Presenting the New Stream Methods

>>Selecting a Search Strategy
A depth-first search traverses the structure from the root
to an arbitrary leaf and then navigates back up toward the root, traversing fully down any
paths it skipped along the way.

a breadth-first search starts at the root and processes all elements of each
particular depth, or distance from the root, before proceeding to the next depth level. The results
are ordered by depth, with all nodes at depth 1 read before all nodes at depth 2, and so on


For the exam, you don’t have to understand the details of each search strategy that Java
employs; you just need to be aware that the Streams API uses depth-first searching with a
default maximum depth of Integer.MAX_VALUE.


>>Walking a Directory
The Files.walk(path) method returns a Stream<Path> object that traverses the directory in a depth-first, lazy manner.

Keep in mind that when you create a Stream<Path> object using Files.walk() , the contents of the directory have not yet been traversed.

Path path = Paths.get("/bigcats");
try {
   Files.walk(path)
        .filter(p -> p.toString().endsWith(".java"))
        .forEach(System.out::println);
} catch (IOException e) {
   // Handle file I/O exception...
}

This example iterates over a directory and outputs all of the fi les that end with a java
extension.

/bigcats/version1/backup/Lion.java
/bigcats/version1/Lion.java
/bigcats/version1/Tiger.java
/bigcats/Lion.java

By default, the method iterates up to Integer.MAX_VALUE directories deep, although
there is an overloaded version of walk(Path,int) that takes a maximum directory depth
integer value as the second parameter. A value of 0 indicates the current path record itself.

Unlike our earlier NIO.2 methods, the walk() method will not traverse symbolic links by
default. Following symbolic links could result in a directory tree that includes other, seemingly
unrelated directories in the search. For example, a symbolic link to the root directory
in a subdirectory means that every file in the system may be traversed.

If you have a situation where you need to change the default behavior and traverse
symbolic links, NIO.2 offers the FOLLOW_LINKS option as a vararg to the walk() method.
Also, be aware that when this option is used, the walk() method will track the paths it has visited,
throwing a FileSystemLoopException if a cycle is detected.


>>Searching a Directory

The Files.find(Path,int,BiPredicate) method behaves in a similar manner as the
Files.walk() method, except that it requires the depth value to be explicitly set along
with a BiPredicate to filter the data. Like walk(), find() also supports the FOLLOW_LINK
vararg option.

Path path = Paths.get("/bigcats");
long dateFilter = 1420070400000l;
try {
   Stream<Path> stream = Files.find(path, 10,(p,a) -> p.toString().endsWith(".java")
					     && a.lastModifiedTime().toMillis() > dateFilter);
   stream.forEach(System.out::println);
} catch (Exception e) {
   // Handle file I/O exception...
}


BiPredicate --> In this case, the two object types are Path and BasicFileAttributes.

This example is similar to our previous Files.walk() example in that it will search
a directory for files that end with the .java extension. It is more advanced, though, in
that it applies a last-modified-time filter using the BasicFileAttributes object. Finally,
it sets the directory depth limit for search to 10, as opposed to relying on the default
Integer.MAX_VALUE value that the Files.walk() method uses.

>>Listing Directory Contents

Files.list(Path)

Consider the following code snippet, assuming that the current working directory is
/zoo:


try {
   Path path = Paths.get("ducks");
   Files.list(path).filter(p -> !Files.isDirectory(p))
                   .map(p -> p.toAbsolutePath())
                   .forEach(System.out::println);
} catch (IOException e) {
   // Handle file I/O exception...
}


/zoo/ducks/food.txt
/zoo/ducks/food-backup.txt
/zoo/ducks/weight.txt

Contrast this method with the Files.walk() method, which traverses all subdirectories.
For the exam, you should be aware that Files.list() searches one level deep and is analogous
to java.io.File.listFiles(), except that it relies on streams.

>>Printing File Contents

Files.readAllLines() and commented that using it to read a very large file could result in an OutOfMemoryError problem.

Files.lines(Path) method that returns a Stream<String> object and does not suffer from this same issue.

The contents of the file are read and processed lazily, which means that only a small portion of the file is stored in memory at any given time.

Path path = Paths.get("/fish/sharks.log");
try {
   Files.lines(path).forEach(System.out::println);
} catch (IOException e) {
   // Handle file I/O exception...
}

Files.readAllLines(path).filter(s -> s.length()>2).forEach(System.out::println);
Files.lines(path).filter(s -> s.length()>2).forEach(System.out::println);

The first line does not compile because the filter() operation cannot be applied to a
Collection without first converting it to a Stream using the stream() method.

=>>Comparing Legacy File and NIO.2 Methods

Legacy Method 			NIO.2 Method
file.exists() 			Files.exists(path)
file.getName() 			path.getFileName()
file.getAbsolutePath() 		path.toAbsolutePath()
file.isDirectory() 		Files.isDirectory(path)
file.isFile() 			Files.isRegularFile(path)
file.isHidden() 		Files.isHidden(path)
file.length() 			Files.size(path)
file.lastModified() 		Files.getLastModifiedTime(path)
file.setLastModified(time) 	Files.setLastModifiedTime(path,fileTime)
file.delete()			Files.delete(path)
file.renameTo(otherFile) 	Files.move(path,otherPath)
file.mkdir() 			Files.createDirectory(path)
file.mkdirs() 			Files.createDirectories(path)
file.listFiles() 		Files.list(path)


>>Cap10


>>Introducing Relational Databases and SQL

A relational database is a database that is organized into tables, which consist of rows
and columns.

>>Writing Basic SQL Statements
INSERT: Add a new row to the table
SELECT: Retrieve data from the table
UPDATE: Change zero or more rows in the table
DELETE: Remove zero or more rows from the table

INSERT INTO species VALUES (3, 'Asian Elephant', 7.5);

SELECT * FROM SPECIES WHERE ID = 3;
SELECT COUNT(*), SUM(num_acres) FROM SPECIES;

UPDATE SPECIES SET NUM_ACRES = NUM_ACRES + .5 WHERE NAME = 'Asian Elephant';

DELETE FROM SPECIES WHERE NAME = 'Asian Elephant';


>>Introducing the Interfaces of JDBC

Each database has a different JAR file with these classes.


With JDBC, you use only the interfaces in your code and never the implementation classes directly.

Interfaces in the JDK

Driver: Knows how to get a connection to the database
Connection: Knows how to communicate with the database
Statement: Knows how to run the SQL
ResultSet: Knows what was returned by a SELECT query

package com.wiley.ocp.connection;
import java.sql.*;

public class MyFirstDatabaseConnection {
   public static void main(String[] args) throws SQLException {
	String url = "jdbc:derby:zoo";
	try (Connection conn = DriverManager.getConnection(url);
	     Statement stmt = conn.createStatement();
	     ResultSet rs = stmt.executeQuery("select name from animal")) {
	   while (rs.next())
	      System.out.println(rs.getString(1));
	}
   }
}



>>Connecting to a Database

>>>Building a JDBC URL


jdbc: postgres: //localhost:5432/zoo


jdbc:derby:zoo

Notice the three parts. It starts with jdbc, then comes derby, and it ends with the database
name. Other examples are shown here:

jdbc:postgresql://localhost/zoo
jdbc:oracle:thin:@123.123.123.123:1521:zoo
jdbc:mysql://localhost:3306/zoo?profileSQL=true


NOT OK:

jdbc:postgresql://local/zoo - local INSTEAND OF localhost 
jdbc:mysql://123456/zoo  - CANNOT BE A NUMBER 
jdbc;oracle;thin;/localhost/zoo - semicolumn


>>>Getting a Database Connection
There are two main ways to get a Connection: DriverManager or DataSource(NOT IN EXAM, bUT IT IS BETTER).

The DriverManager class is in the JDK, as it is an API that comes with Java. It uses the
factory pattern, which means that you call a static method to get a Connection.

import java.sql.*;
public class TestConnect {
   public static void main(String[] args) throws SQLException {
      Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
      System.out.println(conn);
   }
}

java TestConnect : 

Exception in thread "main" java.sql.SQLException: No suitable driver found for
jdbc:derby:zoo
at java.sql.DriverManager.getConnection(DriverManager.java:689)
at java.sql.DriverManager.getConnection(DriverManager.java:270)

java -cp "<java_home>/db/lib/derby.jar:." TestConnect : 

org.apache.derby.impl.jdbc.EmbedConnection40@1372082959
(XID = 156), (SESSIONID = 1), (DATABASE = zoo), (DRDAID = null)


Connection conn = DriverManager.getConnection("jdbc:postgresql://localhost:5432/ocp-book","username","password");

FOR LEGACY CODE: 

public static void main(String[] args) throws SQLException, ClassNotFoundException {
   Class.forName("org.postgresql.Driver"); //can throw a ClassNotFoundException
   Connection conn = DriverManager.getConnection("jdbc:postgresql://localhost:5432/ocp-book",
		                                 "username",
                                                  "password");
}

Class.forName() loads a class. This lets DriverManager use a Driver, even if the JAR
doesn’t have a META-INF/service/java.sql.Driver file. There’s no harm in including
Class.forName(), even if the newer driver does have this file.

***
Having META-INF/service/java.sql.Driver inside the JAR became mandatory with
JDBC 4.0 in Java 6. Before that, some drivers included it and some didn’t.


							JDBC <= 3.0 Driver	JDBC >= 4.0 Driver
Required to contain java.sql.Driver 			No 			Yes
Java will use java.sql.Driver file if present		Yes 			Yes
Required to use Class.forName 				Yes 			No
Allowed to use Class.forName 				Yes 			Yes


>>Obtaining a Statement

In order to run SQL, you need to tell a Statement about it.

Statement stmt = conn.createStatement();

Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY);

This signature takes two parameters. The first is the ResultSet type, and the other is
the ResultSet concurrency mode.

>>>Choosing a ResultSet Type

By default, a ResultSet is in TYPE_FORWARD_ONLY mode. You can go through the data once in the order in which it was retrieved.
Two other modes that you can request when creating a Statement are TYPE_SCROLL_INSENSITIVE and TYPE_SCROLL_SENSITIVE . Both allow you to go through the data in any order.You can go both forward and backward. You can even go to a specifi c spot in the data.

With TYPE_SCROLL_INSENSITIVE , you have a static view of what the ResultSet looked like when you
did the query. If the data changed in the table, you will see it as it was when you did the
query. With TYPE_SCROLL_SENSITIVE , you would see the latest data when scrolling through
the ResultSet .


For scroll sensitive, you only have to know the name and that it isn’t well supported. You don’t need to read or write code with it.


>>>Choosing a ResultSet Concurrency Mode

By default, a ResultSet is in CONCUR_READ_ONLY mode.  It means that you can’t update the result set. Most of the time, you will use INSERT , UPDATE , or DELETE SQL statements to change the database rather than a ResultSet.

CONCUR_UPDATABLE lets you modify the database through the ResultSet.

You have to know read-only mode in detail for the exam. For updatable,
you only have to know the name and that it is not universally
supported.

if the mode you request isn’t available, the driver can downgrade you. This means that if you ask for CONCUR_UPDATABLE , you will likely get a Statement that is CONCUR_READ_ONLY .



>>Executing a Statement

11: Statement stmt = conn.createStatement();
12: int result = stmt.executeUpdate("insert into species values(10, 'Deer', 3)");
14: System.out.println(result); // 1
15: result = stmt.executeUpdate("update species set name = '' where name = 'None'");
17: System.out.println(result); // 0
18: result = stmt.executeUpdate("delete from species where id = 10");
20: System.out.println(result); // 1


ResultSet rs = stmt.executeQuery("select * from species");
Since we are running query to get a result, the return type is ResultSet.

There’s a third method called execute() that can run either a query or an update. It
returns a boolean so that we know whether there is a ResultSet

boolean isResultSet = stmt.execute(sql);
if (isResultSet) {
   ResultSet rs = stmt.getResultSet();
   System.out.println("ran a query");
} else {
   int result = stmt.getUpdateCount();
   System.out.println("ran an update");
}


--WRONG
Connection conn = DriverManager.getConnection("jdbc:derby:zoo");
Statement stmt  = conn.createStatement();
int result      = stmt.executeUpdate("select * from animal");

This throws a SQLException similar to the following: A result was returned when none was expected.



Method 			DELETE  INSERT 	SELECT 	UPDATE
stmt.execute() 		Yes 	Yes 	Yes 	Yes
stmt.executeQuery() 	No 	No 	Yes	No
stmt.executeUpdate() 	Yes 	Yes 	No 	Yes



Method 			Return Type	What Is Returned for SELECT 	What Is Returned for DELETE/INSERT/UPDATE
stmt.execute() 		boolean		true				false
stmt.executeQuery() 	ResultSet	the rows and columns		n/a
stmt.executeUpdate() 	int		n/a				number of rows add/changed/removed






