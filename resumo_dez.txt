sub instanceof pai -> true

class HeavyAnimal { }
class Hippo extends HeavyAnimal { }
class Elephant extends HeavyAnimal { }


12: HeavyAnimal hippo = new Hippo();
13: boolean b1 = hippo instanceof Hippo; // true
14: boolean b2 = hippo instanceof HeavyAnimal; // true
15: boolean b3 = hippo instanceof Elephant; // false


30: Hippo anotherHippo = new Hippo();
31: boolean b5 = anotherHippo instanceof Elephant; // DOES NOT COMPILE

The compiler knows that there is no possible way for a Hippo
variable reference to be an Elephant, since Hippo doesn’t extend Elephant directly or
indirectly.



public interface Mother {}
class Hippo extends HeavyAnimal { }

This code compiles:
42: HeavyAnimal hippo = new Hippo();
43: boolean b6 = hippo instanceof Mother;

It so happens that Hippo does not implement Mother. The compiler allows the statement
because there could later be a class such as this:
class MotherHippo extends Hippo implements Mother { }




Hashcode 
- it can't use more variables than equals() method.
- If equals() returns false when called with two objects, calling hashCode() on each of
those objects does not have to return a different result.
- If equals() returns true when called with two objects, calling hashCode() on each of
those objects must return the same result.
- Within the same program, the result of hashCode() must not change. This means that
you shouldn’t include variables that change in figuring out the hash code.


ENUMS

public enum Season {
   WINTER, SPRING, SUMMER, FALL
}

for(Season season: Season.values()) {
   System.out.println(season.name() + " " + season.ordinal());
}

WINTER 0
SPRING 1
SUMMER 2
FALL 3


You can’t do is extend an enum.

Season summer = Season.SUMMER;
switch (summer) {
	case Season.WINTER: <<---NAO COMPILA DESTA FORMA
		System.out.println("Get out the sled!");
		break;
	case SUMMER: <<--- ASSIM COMPILA
		System.out.println("Time for the pool!");
		break;


apenas aceita construtores privados

somente chama o construtor no momento que carrega;

public enum OnlyOne {
ONCE (true);
private OnlyOne(boolean b) {
System. out .println("constructing");
}
public static void main(String[] args) {
OnlyOne firstCall = OnlyOne. ONCE ; // prints constructing
OnlyOne secondCall = OnlyOne. ONCE ; // doesn't print anything
} }


public enum Season3 {
WINTER {
public void printHours() { System.out.println("short hours"); }
}, SUMMER {
public void printHours() { System.out.println("long hours"); }
}, SPRING, FALL;
public void printHours() { System.out.println("default hours"); }
}

Inner classes 

Inner classes can have the same variable names as outer classes. There is a special way of
calling this to say which class you want to access:

1: public class A {
2: private int x = 10;
3: class B {
4: private int x = 20;
5: class C {
6: private int x = 30;
7: public void allTheX() {
8: System.out.println(x); // 30
9: System.out.println(this.x); // 30
10: System.out.println(B.this.x); // 20
11: System.out.println(A.this.x); // 10


cap2

default method and static in interface only can be public 


polymorphism: 
If you use a variable to refer to an object, then only the methods or variables that are
part of the variable’s reference type can be called without an explicit cast. For example, the
following snippets of code will not compile


1. The type of the object determines which properties exist within the object in memory.
2. The type of the reference to the object determines which methods and variables are
accessible to the Java program.

CAST:

Lemur lemur = new Lemur();
Primate primate = lemur;
Lemur lemur2 = primate; // DOES NOT COMPILE
Lemur lemur3 = (Lemur)primate;
System.out.println(lemur3.age);

1. Casting an object from a subclass to a superclass doesn’t require an explicit cast.
2. Casting an object from a superclass to a subclass requires an explicit cast.
3. The compiler will not allow casts to unrelated types.
4. Even when the code compiles without issue, an exception may be thrown at runtime if
the object being cast is not actually an instance of that class.

cap3

for methods: 
3: public static <T> void sink(T t) { }
4: public static <T> T identity(T t) { return t; }
5: public static T noGood(T t) { return t; } // DOES NOT COMPILE

call:
Box.<String>ship("package");
Box.<String[]>ship(args);


3: java.util.List numbers = new java.util.ArrayList();
4: numbers.add(5);
5: int result = numbers.get(0); // DOES NOT COMPILE

The good news is that unboxing fails with a compiler error rather than a runtime error.
On line 3, we create a raw list. On line 4, we try to add an int to the list. This works
because Java automatically autoboxes to an Integer. On line 5, we have a problem. Since
we aren’t using generics, Java doesn’t know that the list contains an Integer. It just knows
that we have an Object. And an Object can’t be unboxed into an int.


wildcard 	?
upper bound	? extends type
lower bound 	? super type



We can’t write List<Object> l = new ArrayList<String>(); because Java is trying to
protect us from a runtime exception. You might think this would mean that we can’t write
Object[] o = new String[0];. That isn’t the case. This code does compile:
Integer[] numbers = { new Integer(42)};
Object[] objects = numbers;
objects[0] = "forty two"; // throws ArrayStoreException
Although the code does compile, it throws an exception at runtime.


upper bounded:
ArrayList<Number> list = new ArrayList<Integer>(); // DOES NOT COMPILE
List<? extends Number> list = new ArrayList<Integer>();

<B extends A> B method3(List<B> list) {
return new B(); // DOES NOT COMPILE
}
method3() does not compile. <B extends A> says that you want to use B as a type
parameter just for this method and that it needs to extend the A class. Coincidentally, B
is also the name of a class. It isn’t a coincidence. It’s an evil trick. Within the scope of the
method, B can represent classes A, B, or C, because all extend the A class. Since B no longer
refers to the B class in the method, you can’t instantiate it.


<X> void method5(List<X super B> list) { // DOES NOT COMPILE
}
method5() does not compile because it tries to mix a method-specific type parameter
with a wildcard. A wildcard must have a ? in it.


[] List: A list is an ordered collection of elements that allows duplicate entries. Elements
in a list can be accessed by an int index.
[] Set: A set is a collection that does not allow duplicate entries.
[] Queue: A queue is a collection that orders its elements in a specific order for processing.
A typical queue processes its elements in a first-in, first-out order, but other orderings
are possible.
[] Map: A map is a collection that maps keys to values, with no duplicate keys allowed.
The elements in a map are key/value pairs.


boolean add(E element)

boolean remove(Object object)
boolean remove(int index) //overload
Since calling remove() with an int uses the index, an index that doesn’t
exist will throw an exception.

boolean isEmpty()

int size()

void clear()

boolean contains(Object object)
This method calls equals() on each element of the ArrayList

-----------------

>>List

ArrayList

LinkedList(implements both List and Queue)
The main benefits of a LinkedList are that you can access, add, and remove from the
beginning and end of the list in constant time.

Vector (is thread-safe)

Stack
is a data structure where you add and remove elements from the top of the stack. 
If you need a stack, use an ArrayDeque instead.


void add(E element)
void add(int index, E element)
E get(int index)
int indexOf(Object o) -1 	return the first matching index, -1 if not found 
int lastIndexOf(Object o)	return the last matching index, -1 if not found
void remove(int index)
E set(int index, E e)


Iterator iter = list.iterator();
while(iter.hasNext()) {
String string = (String) iter.next();
System.out.println(string);
}

or

Iterator<String> iter = list.iterator();
while(iter.hasNext()) {
String string = iter.next();
System.out.println(string);
}

-----------------


>>Using the Set Interface

HashSet
The main benefit is that adding elements and checking if an element is in the set both
have constant time. The tradeoff is that you lose the order in which you inserted the
elements.

TreeSet
stores its elements in a sorted tree structure. TreeSet implements a special interface called NavigableSet, which
lets you slice up the collection.


The NavigableSet Interface
Method 		Description
E lower(E e) 	Returns greatest element that is < e,  or null if no such element
E floor(E e) 	Returns greatest element that is <= e, or null if no such element
E ceiling(E e) 	Returns smallest element that is >= e, or null if no such element
E higher(E e) 	Returns smallest element that is > e,  or null if no such element

36: NavigableSet<Integer> set = new TreeSet<>();
37: for (int i = 1; i <= 20; i++) set.add(i);
38: System.out.println(set.lower(10)); // 9
39: System.out.println(set.floor(10)); // 10
40: System.out.println(set.ceiling(20)); // 20
41: System.out.println(set.higher(20)); // null


------------------------------------------------

>>Using the Queue Interface

a queue is assumed to be FIFO (first-in, first-out).

LinkedList: 
The main benefit of a LinkedList is that it implements both the List and Queue interfaces. The tradeoff is that it isn’t as efficient as a “pure” queue.

ArrayDeque:
An ArrayDeque is a “pure” double-ended queue. The main benefit of an ArrayDeque is that it is more
efficient than a LinkedList.

ArrayDeque

boolean add(E e) 	Adds an element to the back of the queue and returns true or throws an exception

E element()             Returns next element or throws an exception if empty queue 

boolean offer(E e)	Adds an element to the back of the queue and returns whether successful

E remove()		Removes and returns next element or throws an exception if empty queue

void push(E e) 		Adds an element to the front of the queue

E poll() 		Removes and returns next element or returns null if empty queue

E peek() 		Returns next element or returns null if empty queue

E pop() 		Removes and returns next element or throws an exception if empty queue


12: Queue<Integer> queue = new ArrayDeque<>();
13: System.out.println(queue.offer(10)); // true   [10] 
14: System.out.println(queue.offer(4)); // true	   [10,4] 	
15: System.out.println(queue.peek()); // 10	   [10,4]
16: System.out.println(queue.poll()); // 10	   [4]
17: System.out.println(queue.poll()); // 4	   []	
18: System.out.println(queue.peek()); // null      []


LIFO (stack): 		  push/poll/peek
FIFO (single-endedqueue): offer/poll/peek

 
stack: 

12: ArrayDeque<Integer> stack = new ArrayDeque<>();
13: stack.push(10); 					[10]
14: stack.push(4);					[4,10]
15: System.out.println(stack.peek()); // 4
16: System.out.println(stack.poll()); // 4		[10]
17: System.out.println(stack.poll()); // 10		[]
18: System.out.println(stack.peek()); // null		[]



To review, a queue is like a line of people. You get on in the back and off
in the front. A stack is like a stack of plates. You put the plate on the top and take it off
the top. Since the stack is implemented using ArrayDeque, we refer to “top” and “front”
interchangeably.
A LinkedList works the exact same way as ArrayDeque, so we will skip showing the
code for that one.

------------------------------------------------------------------

>>>Map

HashMap

TreeMap - the keys are always in sorted order. 

A Hashtable - is like Vector in that it is really old and thread-safe and that you won’t be
expected to use it.



void clear() 			Removes all keys and values from the map.

boolean isEmpty() 		Returns whether the map is empty.

int size() 			Returns the number of entries (key/value pairs) in the map.

V get(Object key) 		Returns the value mapped by key or null if none is mapped.

V put(K key, V value) 		Adds or replaces key/value pair. Returns previous value or null.

V remove(Object key) 		Removes and returns value mapped to key. Returns null if none.

boolean containsKey(Object key) Returns whether key is in map.

boolean containsValue(Object)	Returns value is in map.

Set<K> keySet() 		Returns set of all keys.

Collection<V> values() 		Returns Collection of all values.


Map<String, String> map = new HashMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
System.out.print(key + ","); // koala,giraffe,lion,


Map<String, String> map = new TreeMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
System.out.print(key + ","); // giraffe,koala,lion,


System.out.println(map.contains("lion")); // DOES NOT COMPILE
System.out.println(map.containsKey("lion")); // true
System.out.println(map.containsValue("lion")); // false
System.out.println(map.size()); // 3



Type	Can contain		Elements	Has keys	Must add/remove
	duplicate elements?	ordered?	and values?	in specific order?


List 	Yes 			Yes (by index) 	No 		No
Map 	Yes (for values) 	No 		Yes 		No
Queue 	Yes 			Yes (retrieved 	No 		Yes
				    in defined order)

Set 	No 			No 		No 		No


TreeMap		—no null keys
Hashtable	—no null keys or values
TreeSet		—no null elements
ArrayDeque	—no null elements



String: As far as the exam is concerned, that means numbers sort before letters and uppercase letters sort before lowercase letters

java.lang
Interface Comparable<T>


public interface Comparable<T> {
   public int compareTo(T o);
}

public class Duck implements Comparable<Duck> {

  [...]
  public int compareTo(Duck d) {
     return name.compareTo(d.name); // call String's compareTo
  }
  [...]
}


[] The number zero is returned when the current object is equal to the argument to compareTo().
[] A number less than zero is returned when the current object is smaller than the argument
to compareTo().
[] A number greater than zero is returned when the current object is larger than the argument
to compareTo().

comparteTo expeted only objects, primitives types are note allowed. 

Remember that id – a.id sorts in ascending order and a.id – id sorts in
descending order.



java.util
Interface Comparator<T>



Comparator<Duck> byWeight = new Comparator<Duck>() {
public int compare(Duck d1, Duck d2) {
return d1.getWeight()—d2.getWeight();
}
};



public class MultiFieldComparator implements Comparator<Squirrel> {
   public int compare(Squirrel s1, Squirrel s2) {
      int result = s1.getSpecies().compareTo(s2.getSpecies());
      if (result != 0) return result;
      return s1.getWeight()—s2.getWeight();
   }
}

public class ChainingComparator implements Comparator<Squirrel> {
   public int compare(Squirrel s1, Squirrel s2) {
      Comparator<Squirrel> c = Comparator.comparing(s -> s.getSpecies());
      c = c.thenComparingInt(s -> s.getWeight());
      return c.compare(s1, s2);
   }
}

We grant you that it is the same number of lines. The second one is easier to read,
though. It describes what we are doing nicely. First we sort by species, and then
we sort by weight. We could have used method chaining to write this all on one
line.



1: import java.util.*;
2: public class SortRabbits {
3: static class Rabbit{ int id; }
4: public static void main(String[] args) {
5: List<Rabbit> rabbits = new ArrayList<>();
6: rabbits.add(new Rabbit());
7: Collections.sort(rabbits); // DOES NOT COMPILE
8: } }

Java knows that the Rabbit class is not Comparable. It knows sorting will fail, so it
doesn’t even let the code compile.


import java.util.*;
public class SortRabbits {
static class Rabbit{ int id; }
public static void main(String[] args) {
List<Rabbit> rabbits = new ArrayList<>();
rabbits.add(new Rabbit());
Comparator<Rabbit> c = (r1, r2) -> r1.id - r2.id;
Collections.sort(rabbits, c);
} }


sort() and binarySearch() allow you to pass in a Comparator object when you don’t want
to use the natural order. 

3: List<String> names = Arrays.asList("Fluffy", "Hoppy");
4: Comparator<String> c = Comparator.reverseOrder();
5: int index = Collections.binarySearch(names, "Hoppy", c);
6: System.out.println(index); //-1

You do need to know that the answer is not defined. Line 3 creates a list, [Fluffy,
Hoppy]. This list happens to be sorted in ascending order. Line 4 creates a Comparator that
reverses the natural order. Line 5 requests a binary search in descending order. Since the list
is in ascending order, we don’t meet the precondition for doing a search.




2: public class UseTreeSet {
3: static class Rabbit{ int id; }
4: public static void main(String[] args) {
5: Set<Duck> ducks = new TreeSet<>();
6: ducks.add(new Duck("Puddles"));
7: Set<Rabbit> rabbit = new TreeSet<>();
8: rabbit.add(new Rabbit()); // throws an exception
9: } }
Line 6 is fine. Duck does implement Comparable. TreeSet is able to sort it into the proper
position in the set. Line 8 is a problem. When TreeSet tries to sort it, Java discovers the
fact that Rabbit does not implement Comparable. Java throws an exception that looks like
this:
Exception in thread "main" java.lang.ClassCastException: comparing.Rabbit cannot
be cast to java.lang.Comparable


Just like searching and sorting, you can tell collections that require sorting that you wish
to use a specific Comparator, for example:

Set<Rabbit> rabbit = new TreeSet<>(new Comparator<Rabbit>() {
public int compare(Rabbit r1, Rabbit r2) {
return r1.id = r2.id;
}
});
rabbit.add(new Rabbit());


There are four formats for method references:
[] Static methods
[] Instance methods on a particular instance
[] Instance methods on an instance to be determined at runtime
[] Constructors


14: Consumer<List<Integer>> methodRef1 = Collections::sort;
15: Consumer<List<Integer>> lambda1 = l -> Collections.sort(l);

16: String str = "abc";
17: Predicate<String> methodRef2 = str::startsWith;
18: Predicate<String> lambda2 = s -> str.startsWith(s);

19: Predicate<String> methodRef3 = String::isEmpty;
20: Predicate<String> lambda3 = s -> s.isEmpty();


Line 19 says the method that we want to call is declared in String. It looks like a static
method, but it isn’t. Instead, Java knows that isEmpty is an instance method that does not
take any parameters. Java uses the parameter supplied at runtime as the instance on which
the method is called.

21: Supplier<ArrayList> methodRef4 = ArrayList::new;
22: Supplier<ArrayList> lambda4 = () -> new ArrayList();



-----------

boolean removeIf(Predicate<? super E> filter)

How would you replace line 8 with a method reference? Trick question—you can’t. Since
startsWith takes a parameter that isn’t s, it needs to be specified “the long way.”

The most important thing to remember about removeIf is that it is one of two methods that are on a collection and it takes a lambda parameter.

---
Another new method introduced on Lists is replaceAll.

void replaceAll(UnaryOperator<E> o)

List<Integer> list = Arrays.asList(1, 2, 3);
list.replaceAll(x -> x*2);
System.out.println(list); // [2, 4, 6]


----

putIfAbsent(), that you can call if you want to set a
value in the map, but this method skips it if the value is already set to a non-null value

Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", null);
favorites.putIfAbsent("Jenny", "Tram");
favorites.putIfAbsent("Sam", "Tram");
favorites.putIfAbsent("Tom", "Tram");
System.out.println(favorites); // {Tom=Tram, Jenny=Bus Tour, Sam=Tram}



merge --> NOT IN THE EXAM

11: BiFunction<String, String, String> mapper = (v1, v2)
12: -> v1.length() > v2.length() ? v1: v2;
13:
14: Map<String, String> favorites = new HashMap<>();
15: favorites.put("Jenny", "Bus Tour");
16: favorites.put("Tom", "Tram");
17:
18: String jenny = favorites.merge("Jenny", "Skyride", mapper);
19: String tom = favorites.merge("Tom", "Skyride", mapper);
20:
21: System.out.println(favorites); // {Tom=Skyride, Jenny=Bus Tour}
22: System.out.println(jenny); // Bus Tour
23: System.out.println(tom); // Skyride

The merge() method also has logic for what happens if nulls or missing keys are
involved. In this case, it doesn’t call the BiFunction at all, and it simply uses the new
value:

Notice that the mapping function isn’t called. If it were, we’d have a
NullPointerException. The mapping function is used only when there are two actual values
to decide between.


BiFunction<String, String, String> mapper = (v1, v2) -> null;
Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", "Bus Tour");
favorites.merge("Jenny", "Skyride", mapper);
favorites.merge("Sam", "Skyride", mapper);
System.out.println(favorites); // {Tom=Bus Tour, Sam=Skyride}

Tom was left alone since there was no merge() call for that key. Sam was added since
that key was not in the original list. Jenny was removed because the mapping function
returned null.

---

NOT IN THE EXAM 
In a nutshell, computeIfPresent() calls the BiFunction if the requested key is found.
For computeIfAbsent(), the functional interface runs only when the key isn’t present or
is null:

