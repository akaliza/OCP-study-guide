sub instanceof pai -> true

class HeavyAnimal { }
class Hippo extends HeavyAnimal { }
class Elephant extends HeavyAnimal { }


12: HeavyAnimal hippo = new Hippo();
13: boolean b1 = hippo instanceof Hippo; // true
14: boolean b2 = hippo instanceof HeavyAnimal; // true
15: boolean b3 = hippo instanceof Elephant; // false


30: Hippo anotherHippo = new Hippo();
31: boolean b5 = anotherHippo instanceof Elephant; // DOES NOT COMPILE

The compiler knows that there is no possible way for a Hippo
variable reference to be an Elephant, since Hippo doesn’t extend Elephant directly or
indirectly.



public interface Mother {}
class Hippo extends HeavyAnimal { }

This code compiles:
42: HeavyAnimal hippo = new Hippo();
43: boolean b6 = hippo instanceof Mother;

It so happens that Hippo does not implement Mother. The compiler allows the statement
because there could later be a class such as this:
class MotherHippo extends Hippo implements Mother { }




Hashcode 
- it can't use more variables than equals() method.
- If equals() returns false when called with two objects, calling hashCode() on each of
those objects does not have to return a different result.
- If equals() returns true when called with two objects, calling hashCode() on each of
those objects must return the same result.
- Within the same program, the result of hashCode() must not change. This means that
you shouldn’t include variables that change in figuring out the hash code.


ENUMS

public enum Season {
   WINTER, SPRING, SUMMER, FALL
}

for(Season season: Season.values()) {
   System.out.println(season.name() + " " + season.ordinal());
}

WINTER 0
SPRING 1
SUMMER 2
FALL 3


You can’t do is extend an enum.

Season summer = Season.SUMMER;
switch (summer) {
	case Season.WINTER: <<---NAO COMPILA DESTA FORMA
		System.out.println("Get out the sled!");
		break;
	case SUMMER: <<--- ASSIM COMPILA
		System.out.println("Time for the pool!");
		break;


apenas aceita construtores privados

somente chama o construtor no momento que carrega;

public enum OnlyOne {
ONCE (true);
private OnlyOne(boolean b) {
System. out .println("constructing");
}
public static void main(String[] args) {
OnlyOne firstCall = OnlyOne. ONCE ; // prints constructing
OnlyOne secondCall = OnlyOne. ONCE ; // doesn't print anything
} }


public enum Season3 {
WINTER {
public void printHours() { System.out.println("short hours"); }
}, SUMMER {
public void printHours() { System.out.println("long hours"); }
}, SPRING, FALL;
public void printHours() { System.out.println("default hours"); }
}

Inner classes 

Inner classes can have the same variable names as outer classes. There is a special way of
calling this to say which class you want to access:

1: public class A {
2: private int x = 10;
3: class B {
4: private int x = 20;
5: class C {
6: private int x = 30;
7: public void allTheX() {
8: System.out.println(x); // 30
9: System.out.println(this.x); // 30
10: System.out.println(B.this.x); // 20
11: System.out.println(A.this.x); // 10


cap2

default method and static in interface only can be public 


polymorphism: 
If you use a variable to refer to an object, then only the methods or variables that are
part of the variable’s reference type can be called without an explicit cast. For example, the
following snippets of code will not compile


1. The type of the object determines which properties exist within the object in memory.
2. The type of the reference to the object determines which methods and variables are
accessible to the Java program.

CAST:

Lemur lemur = new Lemur();
Primate primate = lemur;
Lemur lemur2 = primate; // DOES NOT COMPILE
Lemur lemur3 = (Lemur)primate;
System.out.println(lemur3.age);

1. Casting an object from a subclass to a superclass doesn’t require an explicit cast.
2. Casting an object from a superclass to a subclass requires an explicit cast.
3. The compiler will not allow casts to unrelated types.
4. Even when the code compiles without issue, an exception may be thrown at runtime if
the object being cast is not actually an instance of that class.

cap3

for methods: 
3: public static <T> void sink(T t) { }
4: public static <T> T identity(T t) { return t; }
5: public static T noGood(T t) { return t; } // DOES NOT COMPILE

call:
Box.<String>ship("package");
Box.<String[]>ship(args);


3: java.util.List numbers = new java.util.ArrayList();
4: numbers.add(5);
5: int result = numbers.get(0); // DOES NOT COMPILE

The good news is that unboxing fails with a compiler error rather than a runtime error.
On line 3, we create a raw list. On line 4, we try to add an int to the list. This works
because Java automatically autoboxes to an Integer. On line 5, we have a problem. Since
we aren’t using generics, Java doesn’t know that the list contains an Integer. It just knows
that we have an Object. And an Object can’t be unboxed into an int.


wildcard 	?
upper bound	? extends type
lower bound 	? super type



We can’t write List<Object> l = new ArrayList<String>(); because Java is trying to
protect us from a runtime exception. You might think this would mean that we can’t write
Object[] o = new String[0];. That isn’t the case. This code does compile:
Integer[] numbers = { new Integer(42)};
Object[] objects = numbers;
objects[0] = "forty two"; // throws ArrayStoreException
Although the code does compile, it throws an exception at runtime.


upper bounded:
ArrayList<Number> list = new ArrayList<Integer>(); // DOES NOT COMPILE
List<? extends Number> list = new ArrayList<Integer>();

<B extends A> B method3(List<B> list) {
return new B(); // DOES NOT COMPILE
}
method3() does not compile. <B extends A> says that you want to use B as a type
parameter just for this method and that it needs to extend the A class. Coincidentally, B
is also the name of a class. It isn’t a coincidence. It’s an evil trick. Within the scope of the
method, B can represent classes A, B, or C, because all extend the A class. Since B no longer
refers to the B class in the method, you can’t instantiate it.


<X> void method5(List<X super B> list) { // DOES NOT COMPILE
}
method5() does not compile because it tries to mix a method-specific type parameter
with a wildcard. A wildcard must have a ? in it.


[] List: A list is an ordered collection of elements that allows duplicate entries. Elements
in a list can be accessed by an int index.
[] Set: A set is a collection that does not allow duplicate entries.
[] Queue: A queue is a collection that orders its elements in a specific order for processing.
A typical queue processes its elements in a first-in, first-out order, but other orderings
are possible.
[] Map: A map is a collection that maps keys to values, with no duplicate keys allowed.
The elements in a map are key/value pairs.


boolean add(E element)

boolean remove(Object object)
boolean remove(int index) //overload
Since calling remove() with an int uses the index, an index that doesn’t
exist will throw an exception.

boolean isEmpty()

int size()

void clear()

boolean contains(Object object)
This method calls equals() on each element of the ArrayList

-----------------

>>List

ArrayList

LinkedList(implements both List and Queue)
The main benefits of a LinkedList are that you can access, add, and remove from the
beginning and end of the list in constant time.

Vector (is thread-safe)

Stack
is a data structure where you add and remove elements from the top of the stack. 
If you need a stack, use an ArrayDeque instead.


void add(E element)
void add(int index, E element)
E get(int index)
int indexOf(Object o) -1 	return the first matching index, -1 if not found 
int lastIndexOf(Object o)	return the last matching index, -1 if not found
void remove(int index)
E set(int index, E e)


Iterator iter = list.iterator();
while(iter.hasNext()) {
String string = (String) iter.next();
System.out.println(string);
}

or

Iterator<String> iter = list.iterator();
while(iter.hasNext()) {
String string = iter.next();
System.out.println(string);
}

-----------------


>>Using the Set Interface

HashSet
The main benefit is that adding elements and checking if an element is in the set both
have constant time. The tradeoff is that you lose the order in which you inserted the
elements.

TreeSet
stores its elements in a sorted tree structure. TreeSet implements a special interface called NavigableSet, which
lets you slice up the collection.


The NavigableSet Interface
Method 		Description
E lower(E e) 	Returns greatest element that is < e,  or null if no such element
E floor(E e) 	Returns greatest element that is <= e, or null if no such element
E ceiling(E e) 	Returns smallest element that is >= e, or null if no such element
E higher(E e) 	Returns smallest element that is > e,  or null if no such element

36: NavigableSet<Integer> set = new TreeSet<>();
37: for (int i = 1; i <= 20; i++) set.add(i);
38: System.out.println(set.lower(10)); // 9
39: System.out.println(set.floor(10)); // 10
40: System.out.println(set.ceiling(20)); // 20
41: System.out.println(set.higher(20)); // null


------------------------------------------------

>>Using the Queue Interface

a queue is assumed to be FIFO (first-in, first-out).

LinkedList: 
The main benefit of a LinkedList is that it implements both the List and Queue interfaces. The tradeoff is that it isn’t as efficient as a “pure” queue.

ArrayDeque:
An ArrayDeque is a “pure” double-ended queue. The main benefit of an ArrayDeque is that it is more
efficient than a LinkedList.

ArrayDeque

boolean add(E e) 	Adds an element to the back of the queue and returns true or throws an exception

E element()             Returns next element or throws an exception if empty queue 

boolean offer(E e)	Adds an element to the back of the queue and returns whether successful

E remove()		Removes and returns next element or throws an exception if empty queue

void push(E e) 		Adds an element to the front of the queue

E poll() 		Removes and returns next element or returns null if empty queue

E peek() 		Returns next element or returns null if empty queue

E pop() 		Removes and returns next element or throws an exception if empty queue


12: Queue<Integer> queue = new ArrayDeque<>();
13: System.out.println(queue.offer(10)); // true   [10] 
14: System.out.println(queue.offer(4)); // true	   [10,4] 	
15: System.out.println(queue.peek()); // 10	   [10,4]
16: System.out.println(queue.poll()); // 10	   [4]
17: System.out.println(queue.poll()); // 4	   []	
18: System.out.println(queue.peek()); // null      []


LIFO (stack): 		  push/poll/peek
FIFO (single-endedqueue): offer/poll/peek

 
stack: 

12: ArrayDeque<Integer> stack = new ArrayDeque<>();
13: stack.push(10); 					[10]
14: stack.push(4);					[4,10]
15: System.out.println(stack.peek()); // 4
16: System.out.println(stack.poll()); // 4		[10]
17: System.out.println(stack.poll()); // 10		[]
18: System.out.println(stack.peek()); // null		[]



To review, a queue is like a line of people. You get on in the back and off
in the front. A stack is like a stack of plates. You put the plate on the top and take it off
the top. Since the stack is implemented using ArrayDeque, we refer to “top” and “front”
interchangeably.
A LinkedList works the exact same way as ArrayDeque, so we will skip showing the
code for that one.

------------------------------------------------------------------

>>>Map

HashMap

TreeMap - the keys are always in sorted order. 

A Hashtable - is like Vector in that it is really old and thread-safe and that you won’t be
expected to use it.



void clear() 			Removes all keys and values from the map.

boolean isEmpty() 		Returns whether the map is empty.

int size() 			Returns the number of entries (key/value pairs) in the map.

V get(Object key) 		Returns the value mapped by key or null if none is mapped.

V put(K key, V value) 		Adds or replaces key/value pair. Returns previous value or null.

V remove(Object key) 		Removes and returns value mapped to key. Returns null if none.

boolean containsKey(Object key) Returns whether key is in map.

boolean containsValue(Object)	Returns value is in map.

Set<K> keySet() 		Returns set of all keys.

Collection<V> values() 		Returns Collection of all values.


Map<String, String> map = new HashMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
System.out.print(key + ","); // koala,giraffe,lion,


Map<String, String> map = new TreeMap<>();
map.put("koala", "bamboo");
map.put("lion", "meat");
map.put("giraffe", "leaf");
String food = map.get("koala"); // bamboo
for (String key: map.keySet())
System.out.print(key + ","); // giraffe,koala,lion,


System.out.println(map.contains("lion")); // DOES NOT COMPILE
System.out.println(map.containsKey("lion")); // true
System.out.println(map.containsValue("lion")); // false
System.out.println(map.size()); // 3



Type	Can contain		Elements	Has keys	Must add/remove
	duplicate elements?	ordered?	and values?	in specific order?


List 	Yes 			Yes (by index) 	No 		No
Map 	Yes (for values) 	No 		Yes 		No
Queue 	Yes 			Yes (retrieved 	No 		Yes
				    in defined order)

Set 	No 			No 		No 		No


TreeMap		—no null keys
Hashtable	—no null keys or values
TreeSet		—no null elements
ArrayDeque	—no null elements



String: As far as the exam is concerned, that means numbers sort before letters and uppercase letters sort before lowercase letters

java.lang
Interface Comparable<T>


public interface Comparable<T> {
   public int compareTo(T o);
}

public class Duck implements Comparable<Duck> {

  [...]
  public int compareTo(Duck d) {
     return name.compareTo(d.name); // call String's compareTo
  }
  [...]
}


[] The number zero is returned when the current object is equal to the argument to compareTo().
[] A number less than zero is returned when the current object is smaller than the argument
to compareTo().
[] A number greater than zero is returned when the current object is larger than the argument
to compareTo().

comparteTo expeted only objects, primitives types are note allowed. 

Remember that id – a.id sorts in ascending order and a.id – id sorts in
descending order.



java.util
Interface Comparator<T>



Comparator<Duck> byWeight = new Comparator<Duck>() {
public int compare(Duck d1, Duck d2) {
return d1.getWeight()—d2.getWeight();
}
};



public class MultiFieldComparator implements Comparator<Squirrel> {
   public int compare(Squirrel s1, Squirrel s2) {
      int result = s1.getSpecies().compareTo(s2.getSpecies());
      if (result != 0) return result;
      return s1.getWeight()—s2.getWeight();
   }
}

public class ChainingComparator implements Comparator<Squirrel> {
   public int compare(Squirrel s1, Squirrel s2) {
      Comparator<Squirrel> c = Comparator.comparing(s -> s.getSpecies());
      c = c.thenComparingInt(s -> s.getWeight());
      return c.compare(s1, s2);
   }
}

We grant you that it is the same number of lines. The second one is easier to read,
though. It describes what we are doing nicely. First we sort by species, and then
we sort by weight. We could have used method chaining to write this all on one
line.



1: import java.util.*;
2: public class SortRabbits {
3: static class Rabbit{ int id; }
4: public static void main(String[] args) {
5: List<Rabbit> rabbits = new ArrayList<>();
6: rabbits.add(new Rabbit());
7: Collections.sort(rabbits); // DOES NOT COMPILE
8: } }

Java knows that the Rabbit class is not Comparable. It knows sorting will fail, so it
doesn’t even let the code compile.


import java.util.*;
public class SortRabbits {
static class Rabbit{ int id; }
public static void main(String[] args) {
List<Rabbit> rabbits = new ArrayList<>();
rabbits.add(new Rabbit());
Comparator<Rabbit> c = (r1, r2) -> r1.id - r2.id;
Collections.sort(rabbits, c);
} }


sort() and binarySearch() allow you to pass in a Comparator object when you don’t want
to use the natural order. 

3: List<String> names = Arrays.asList("Fluffy", "Hoppy");
4: Comparator<String> c = Comparator.reverseOrder();
5: int index = Collections.binarySearch(names, "Hoppy", c);
6: System.out.println(index); //-1

You do need to know that the answer is not defined. Line 3 creates a list, [Fluffy,
Hoppy]. This list happens to be sorted in ascending order. Line 4 creates a Comparator that
reverses the natural order. Line 5 requests a binary search in descending order. Since the list
is in ascending order, we don’t meet the precondition for doing a search.




2: public class UseTreeSet {
3: static class Rabbit{ int id; }
4: public static void main(String[] args) {
5: Set<Duck> ducks = new TreeSet<>();
6: ducks.add(new Duck("Puddles"));
7: Set<Rabbit> rabbit = new TreeSet<>();
8: rabbit.add(new Rabbit()); // throws an exception
9: } }
Line 6 is fine. Duck does implement Comparable. TreeSet is able to sort it into the proper
position in the set. Line 8 is a problem. When TreeSet tries to sort it, Java discovers the
fact that Rabbit does not implement Comparable. Java throws an exception that looks like
this:
Exception in thread "main" java.lang.ClassCastException: comparing.Rabbit cannot
be cast to java.lang.Comparable


Just like searching and sorting, you can tell collections that require sorting that you wish
to use a specific Comparator, for example:

Set<Rabbit> rabbit = new TreeSet<>(new Comparator<Rabbit>() {
public int compare(Rabbit r1, Rabbit r2) {
return r1.id = r2.id;
}
});
rabbit.add(new Rabbit());


There are four formats for method references:
[] Static methods
[] Instance methods on a particular instance
[] Instance methods on an instance to be determined at runtime
[] Constructors


14: Consumer<List<Integer>> methodRef1 = Collections::sort;
15: Consumer<List<Integer>> lambda1 = l -> Collections.sort(l);

16: String str = "abc";
17: Predicate<String> methodRef2 = str::startsWith;
18: Predicate<String> lambda2 = s -> str.startsWith(s);

19: Predicate<String> methodRef3 = String::isEmpty;
20: Predicate<String> lambda3 = s -> s.isEmpty();


Line 19 says the method that we want to call is declared in String. It looks like a static
method, but it isn’t. Instead, Java knows that isEmpty is an instance method that does not
take any parameters. Java uses the parameter supplied at runtime as the instance on which
the method is called.

21: Supplier<ArrayList> methodRef4 = ArrayList::new;
22: Supplier<ArrayList> lambda4 = () -> new ArrayList();



-----------

boolean removeIf(Predicate<? super E> filter)

How would you replace line 8 with a method reference? Trick question—you can’t. Since
startsWith takes a parameter that isn’t s, it needs to be specified “the long way.”

The most important thing to remember about removeIf is that it is one of two methods that are on a collection and it takes a lambda parameter.

---
Another new method introduced on Lists is replaceAll.

void replaceAll(UnaryOperator<E> o)

List<Integer> list = Arrays.asList(1, 2, 3);
list.replaceAll(x -> x*2);
System.out.println(list); // [2, 4, 6]


----

putIfAbsent(), that you can call if you want to set a
value in the map, but this method skips it if the value is already set to a non-null value

Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", null);
favorites.putIfAbsent("Jenny", "Tram");
favorites.putIfAbsent("Sam", "Tram");
favorites.putIfAbsent("Tom", "Tram");
System.out.println(favorites); // {Tom=Tram, Jenny=Bus Tour, Sam=Tram}



merge --> NOT IN THE EXAM

11: BiFunction<String, String, String> mapper = (v1, v2)
12: -> v1.length() > v2.length() ? v1: v2;
13:
14: Map<String, String> favorites = new HashMap<>();
15: favorites.put("Jenny", "Bus Tour");
16: favorites.put("Tom", "Tram");
17:
18: String jenny = favorites.merge("Jenny", "Skyride", mapper);
19: String tom = favorites.merge("Tom", "Skyride", mapper);
20:
21: System.out.println(favorites); // {Tom=Skyride, Jenny=Bus Tour}
22: System.out.println(jenny); // Bus Tour
23: System.out.println(tom); // Skyride

The merge() method also has logic for what happens if nulls or missing keys are
involved. In this case, it doesn’t call the BiFunction at all, and it simply uses the new
value:

Notice that the mapping function isn’t called. If it were, we’d have a
NullPointerException. The mapping function is used only when there are two actual values
to decide between.


BiFunction<String, String, String> mapper = (v1, v2) -> null;
Map<String, String> favorites = new HashMap<>();
favorites.put("Jenny", "Bus Tour");
favorites.put("Tom", "Bus Tour");
favorites.merge("Jenny", "Skyride", mapper);
favorites.merge("Sam", "Skyride", mapper);
System.out.println(favorites); // {Tom=Bus Tour, Sam=Skyride}

Tom was left alone since there was no merge() call for that key. Sam was added since
that key was not in the original list. Jenny was removed because the mapping function
returned null.

---

NOT IN THE EXAM 
In a nutshell, computeIfPresent() calls the BiFunction if the requested key is found.
For computeIfAbsent(), the functional interface runs only when the key isn’t present or
is null:

Map<String, Integer> counts = new HashMap<>();
counts.put("Jenny", 1);
counts.computeIfPresent("Jenny", (k, v) -> null);
counts.computeIfAbsent("Sam", k -> null);
System.out.println(counts); // {}




cap4

Lambda expressions can access static variables, instance variables, effectively final
method parameters, and effectively final local variables


Functional Interfaces 	# Parameters 	Return Type 	Single Abstract Method
=====================	============	===========	======================
Supplier<T> 		0 		T 		get
Consumer<T> 		1 (T) 		void 		accept
BiConsumer<T, U> 	2 (T, U) 	void 		accept
Predicate<T> 		1 (T) 		boolean 	test
BiPredicate<T, U> 	2 (T, U) 	boolean 	test
Function<T, R> 		1 (T) 		R 		apply
BiFunction<T, U, R> 	2 (T, U) 	R 		apply
UnaryOperator<T> 	1 (T) 		T 		apply
BinaryOperator<T> 	2 (T, T) 	T 		apply


@FunctionalInterface public class Supplier<T> {
   public T get();
}



@FunctionalInterface public class Consumer<T> {
void accept(T t);
}
@FunctionalInterface public class BiConsumer<T, U> {
void accept(T t, U u);
}



@FunctionalInterface public class Predicate<T> {
boolean test(T t);
}
@FunctionalInterface public class BiPredicate<T, U> {
boolean test(T t, U u);
}



@FunctionalInterface public class Function<T, R> {
R apply(T t);
}
@FunctionalInterface public class BiFunction<T, U, R> {
R apply(T t, U u);
}



@FunctionalInterface public class UnaryOperator<T>  extends Function<T, T> { }
@FunctionalInterface public class BinaryOperator<T> extends BiFunction<T, T, T> { }

This means that method signatures look like this:

T apply(T t);
T apply(T t1, T t2);


-----------

Method 			When Optional Is Empty 				When Optional Contains a Value
======================= ===========================================	==============================
get() 			Throws an exception 				Returns value
ifPresent(Consumer c) 	Does nothing 					Calls Consumer c with value
isPresent() 		Returns false 					Returns true
orElse(T other) 	Returns other parameter 			Returns value
orElseGet(Supplier s) 	Returns result of calling Supplier 		Returns value
orElseThrow(Supplier s) Throws exception createdby calling Supplier 	Returns value



10: public static Optional<Double> average(int… scores) {
11: if (scores.length == 0) return Optional.empty();
12: int sum = 0;
13: for (int score: scores) sum += score;
14: return Optional.of((double) sum / scores.length);
15: }


20: Optional<Double> opt = average(90, 100);
21: if (opt.isPresent())
22: System.out.println(opt.get()); // 95.0


26: Optional<Double> opt = average();
27: System.out.println(opt.get()); // bad
We’d get an exception since there is no value inside the Optional:
java.util.NoSuchElementException: No value present


Optional o = (value== null) ? Optional.empty(): Optional.of(value);

Java provides a factory method to do the same thing:
Optional o = Optional.ofNullable(value);


Optional<Double> opt = average(90, 100);
opt.ifPresent(System.out::println);


30: Optional<Double> opt = average();
31: System.out.println(opt.orElse(Double.NaN));
32: System.out.println(opt.orElseGet(() -> Math.random()));
33: System.out.println(opt.orElseThrow(() -> new IllegalStateException()));

NaN
0.49775932295380165
Exception in thread "main" java.lang.IllegalStateException
at optional.Average.lambda$3(Average.java:56)
at optional.Average$$Lambda$5/455659002.get(Unknown Source)
at java.util.Optional.orElseThrow(Optional.java:290)


System.out.println(opt.orElseGet(
() -> new IllegalStateException())); // DOES NOT COMPILE

opt is an Optional<Double>. This means the Supplier must return a Double. Since this
supplier returns an exception, the type does not match.

-------------------------------------------------------------------


1: Stream<String> empty = Stream.empty(); // count = 0
2: Stream<Integer> singleElement = Stream.of(1); // count = 1
3: Stream<Integer> fromArray = Stream.of(1, 2, 3); // count = 2 //varargs

4: List<String> list = Arrays.asList("a", "b", "c");
5: Stream<String> fromList = list.stream();
6: Stream<String> fromListParallel = list.parallelStream();


7: Stream<Double> randoms = Stream.generate(Math::random);
8: Stream<Integer> oddNumbers = Stream.iterate(1, n -> n + 2);

If you call randoms.forEach(System.out::println) , the program will
print random numbers until you kill it.


iterate() takes a seed or starting value as the fi rst
parameter. This is the fi rst element that will be part of the stream. The other parameter is a
lambda expression that gets passed the previous value and generates the next value. As with
the random numbers example, it will keep on producing odd numbers as long as you need
them.

------------------
Terminal Operations

Method 			What Happens for Infinite Streams 	Return Value 	Reduction
=================	===================================	=============	=========
allMatch()		Sometimes terminates 			boolean 	No
/anyMatch()
/noneMatch()
 
collect() 		Does not terminate 			Varies 		Yes

count() 		Does not terminate 			long 		Yes

findAny()		Terminates 				Optional<T> 	No
/findFirst()

forEach() 		Does not terminate 			void 		No

min()/max() 		Does not terminate 			Optional<T> 	Yes

reduce() 		Does not terminate 			Varies 		Yes




long count()

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
System.out.println(s.count()); // 3

--

Optional<T> min(<? super T> comparator)
Optional<T> max(<? super T> comparator)

Stream<String> s = Stream.of("monkey", "ape", "bonobo");
Optional<String> min = s.min((s1, s2) -> s1.length()—s2.length());
min.ifPresent(System.out::println); // ape

Optional<?> minEmpty = Stream.empty().min((s1, s2) -> 0);
System.out.println(minEmpty.isPresent()); // false

Since the stream is empty, the comparator is never called and no value is present in the
Optional.


--

Optional<T> findAny()
Optional<T> findFirst()

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
Stream<String> infinite = Stream.generate(() -> "chimp");
s.findAny().ifPresent(System.out::println); // monkey
infinite.findAny().ifPresent(System.out::println); // chimp

If the stream is empty, they return an empty Optional.

----

boolean anyMatch(Predicate <? super T> predicate)
boolean allMatch(Predicate <? super T> predicate)
boolean noneMatch(Predicate <? super T> predicate)

List<String> list = Arrays.asList("monkey", "2", "chimp");
Stream<String> infinite = Stream.generate(() -> "chimp");
Predicate<String> pred = x -> Character.isLetter(x.charAt(0));
System.out.println(list.stream().anyMatch(pred)); // true
System.out.println(list.stream().allMatch(pred)); // false
System.out.println(list.stream().noneMatch(pred)); // false
System.out.println(infinite.anyMatch(pred)); // true

On the infinite list, one match is found, so the call terminates. If we called noneMatch() or allMatch() ,
they would run until we killed the program.


Remember that allMatch() , anyMatch() , and noneMatch() return a boolean. By contrast, the find methods return an Optional because they return an element of the stream.


-----------

void forEach(Consumer<? super T> action)

Notice that you can’t use a traditional for loop on a stream:
Stream s = Stream.of(1);
for (Integer i: s) {} // DOES NOT COMPILE

--

reduce()

T reduce(T identity, BinaryOperator<T> accumulator)
Optional<T> reduce(BinaryOperator<T> accumulator)
<U> U reduce(U identity, BiFunction<U,? super T,U> accumulator,
BinaryOperator<U> combiner)

Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", (s, c) -> s + c);
System.out.println(word); // wolf

Stream<String> stream = Stream.of("w", "o", "l", "f");
String word = stream.reduce("", String::concat);
System.out.println(word); // wolf

Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, (a, b) -> a*b));

[] If the stream is empty, an empty Optional is returned.
[] If the stream has one element, it is returned.
[] If the stream has multiple elements, the accumulator is applied to combine them.


BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> empty = Stream.empty();
Stream<Integer> oneElement = Stream.of(3);
Stream<Integer> threeElements = Stream.of(3, 5, 6);
empty.reduce(op).ifPresent(System.out::print); // no output
oneElement.reduce(op).ifPresent(System.out::print); // 3
threeElements.reduce(op).ifPresent(System.out::print); // 90

The third method signature is used when we are processing collections in parallel. It
allows Java to create intermediate reductions and then combine them at the end. In our
example, it looks similar. While we aren’t actually using a parallel stream here, Java
assumes that a stream might be parallel. This is helpful because it lets us switch to a parallel
stream easily in the future:



BinaryOperator<Integer> op = (a, b) -> a * b;
Stream<Integer> stream = Stream.of(3, 5, 6);
System.out.println(stream.reduce(1, op, op)); // 90

----

collect()

<R> R collect(Supplier<R> supplier, BiConsumer<R, ? super T> accumulator,
BiConsumer<R, R> combiner)
<R,A> R collect(Collector<? super T, A,R> collector)


Stream<String> stream = Stream.of("w", "o", "l", "f");
StringBuilder word = stream.collect(StringBuilder::new,
StringBuilder::append, StringBuilder:append)

[] The first parameter is a Supplier that creates the object that will store the results as we
collect data. Remember that a Supplier doesn’t take any parameters and returns a value.
In this case, it constructs a new StringBuilder.
[] The second parameter is a BiConsumer, which takes two parameters and doesn’t return
anything. It is responsible for adding one more element to the data collection. In this example,
it appends the next String to the StringBuilder.
[] The final parameter is another BiConsumer. It is responsible for taking two data collections
and merging them. This is useful when we are processing in parallel. Two smaller
collections are formed and then merged into one. This would work with StringBuilder
only if we didn’t care about the order of the letters. In this case, the accumulator and combiner
have similar logic.


Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(TreeSet::new, TreeSet::add,
TreeSet::addAll);
System.out.println(set); // [f, l, o, w]

The collector has three parts as before. The supplier creates an empty TreeSet. The
accumulator adds a single String from the Stream to the TreeSet. The combiner adds all
of the elements of one TreeSet to another in case the operations were done in parallel and
need to be merged.



Stream<String> stream = Stream.of("w", "o", "l", "f");
TreeSet<String> set = stream.collect(Collectors.toCollection(TreeSet::new));
System.out.println(set); // [f, l, o, w]

If we didn’t need the set to be sorted, we could make the code even shorter:
Stream<String> stream = Stream.of("w", "o", "l", "f");
Set<String> set = stream.collect(Collectors.toSet());
System.out.println(set); // [f, w, l, o]
-----------------------------------------------------------

Intermediate Operations


filter()

Stream<T> filter(Predicate<? super T> predicate)

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.filter(x -> x.startsWith("m")).forEach(System.out::print); // monkey


---

distinct()

Stream<T> distinct()

Stream<String> s = Stream.of("duck", "duck", "duck", "goose");
s.distinct().forEach(System.out::print); // duckgoose

---

limit() and skip()

Stream<T> limit(int maxSize)
Stream<T> skip(int n)

Stream<Integer> s = Stream.iterate(1, n -> n + 1);
s.skip(5).limit(2).forEach(System.out::print); // 67

---

map()

<R> Stream<R> map(Function<? super T, ? extends R> mapper)

Stream<String> s = Stream.of("monkey", "gorilla", "bonobo");
s.map(String::length).forEach(System.out::print); // 676

--------
flatMap()

<R> Stream<R> flatMap(Function<? super T, ? extends Stream<? extends R>> mapper)

List<String> zero = Arrays.asList();
List<String> one = Arrays.asList("Bonobo");
List<String> two = Arrays.asList("Mama Gorilla", "Baby Gorilla");
Stream<List<String>> animals = Stream.of(zero, one, two);
animals.flatMap(l -> l.stream()).forEach(System.out::println);

Here’s the output:
Bonobo
Mama Gorilla
Baby Gorilla

---------
sorted()

Stream<T> sorted()
Stream<T> sorted(Comparator<? super T> comparator)

Stream<String> s = Stream.of("brown-", "bear-");
s.sorted().forEach(System.out::print); // bear-brown-

Stream<String> s = Stream.of("brown bear-", "grizzly-");
s.sorted(Comparator.reverseOrder())
.forEach(System.out::print); // grizzly-brown bear-


s.sorted(Comparator::reverseOrder); // DOES NOT COMPILE

Comparator is a functional interface.
This means that we can use method references or lambdas to implement it. The
Comparator interface implements one method that takes two String parameters and
returns an int . However, Comparator::reverseOrder doesn’t do that. It is a reference
to a function that takes zero parameters and returns a Comparator . This is not compatible
with the interface. This means that we have to use a method and not a method
reference. We bring this up to remind you that you really do need to know method references
well.


----

peek()

Stream<T> peek(Consumer<? super T> action)

Stream<String> stream = Stream.of("black bear", "brown bear", "grizzly");
long count = stream.filter(s -> s.startsWith("g"))
.peek(System.out::println).count(); // grizzly
System.out.println(count); // 1

When working with a Queue , peek() looks only at the first element. In a
stream, peek() looks at each element that goes through that part of the
stream pipeline. It’s like having a worker take notes on how a particular
step of the process is doing.

------------

List<String> list = Arrays.asList("Toby", "Anna", "Leroy", "Alex");
list.stream().filter(n -> n.length() == 4).sorted()
.limit(2).forEach(System.out::println);


-----------------------

working with primitives

Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.reduce(0, (s, n) -> s + n));

There is another way of doing that:

Stream<Integer> stream = Stream.of(1, 2, 3);
System.out.println(stream.mapToInt(x -> x).sum());

This time, we converted our Stream<Integer> to an IntStream and asked the IntStream
to calculate the sum for us. The primitive streams know how to perform certain common
operations automatically.


IntStream intStream = IntStream.of(1, 2, 3);
OptionalDouble avg = intStream.average();
System.out.println(avg.getAsDouble());

[] IntStream: Used for the primitive types int, short, byte, and char
[] LongStream: Used for the primitive type long
[] DoubleStream: Used for the primitive types double and float


DoubleStream empty = DoubleStream. empty ();


DoubleStream random = DoubleStream. generate (Math::random);
DoubleStream fractions = DoubleStream. iterate (.5, d -> d / 2);
random.limit(3).forEach(System.out::println);
System.out.println();
fractions.limit(3).forEach(System.out::println);


IntStream range = IntStream.range(1, 6);
range.forEach(System.out::println); //1-5

IntStream rangeClosed = IntStream.rangeClosed(1, 5);
rangeClosed.forEach(System.out::println); //1-5



Source Stream	To Create	To Create	To Create	To Create
Class		Stream		DoubleStream	IntStream	LongStream
=============	==============	===============	===============	================
Stream		map		mapToDouble	mapToInt	mapToLong 
DoubleStream	mapToObj	map		mapToInt	mapToLong
IntStream	mapToObj	mapToDouble	map		mapToLong
LongStream	mapToObj	mapTODouble	mapToInt	map



Stream<String> objStream = Stream.of("penguin", "fish");
IntStream intStream = objStream.mapToInt(s -> s.length());




Source Stream	To Create	To Create		To Create		To Create
Class		Stream		DoubleStream		IntStream		LongStream
=============	==============	===============		===============		================
Stream		Function	ToDoubleFunction	ToIntFunction		ToLongFunction
DoubleStream	DoubleFunction	DoubleUnaryOperator	DoubleToIntFunction	DoubleToLongFunction
IntStream	IntFunction	IntToDoubleFunction	IntUnaryOperator	IntToLongFunction
LongStream	LongFunction	LongToDoubleFunction	LongToIntFunction	LongUnaryOperator


-----------------

IntStream stream = IntStream.rangeClosed(1,10);
OptionalDouble optional = stream.average();


optional.ifPresent(System.out::println);
System.out.println(optional.getAsDouble());
System.out.println(optional.orElseGet(() -> Double.NaN));


orElseGet() takes a DoubleSupplier instead of a Supplier.


				OptionalDouble 	OptionalInt 	OptionalLong
==============================================================================
Getting as a primitive		getAsDouble()	getAsInt()	getAsLong()
orElseGet() parameter type	DoubleSupplier	IntSupplier	LongSupplier
Return type of max()		OptionalDouble	OptionalInt	OptionalLong
Return type of sum()		double		int		long
Return type of avg()		OptionalDouble	OptionalDouble	OptionalDouble



5: LongStream longs = LongStream.of(5, 10);
6: long sum = longs.sum();
7: System.out.println(sum); // 15
8: DoubleStream doubles = DoubleStream.generate(() -> Math.PI);
9: OptionalDouble min = doubles.min(); // runs infinitely

---------------------------

Summarizing Statistics

private static int max(IntStream ints) {
   OptionalInt optional = ints.max();
   return optional.orElseThrow(RuntimeException::new);
}


We
can’t run two terminal operations against the same stream. Luckily, this is a common problem
and the primitive streams solve it for us with summary statistics. Statistic is just a big
word for a number that was calculated from data:

private static int range(IntStream ints) {
   IntSummaryStatistics stats = ints.summaryStatistics();
   if (stats.getCount() == 0) throw new RuntimeException();
   return stats.getMax()—stats.getMin();
}

-----------------------------


Functional Interfaces for boolean

boolean getAsBoolean()

12: BooleanSupplier b1 = () -> true;
13: BooleanSupplier b2 = () -> Math.random() > .5;
14: System.out.println(b1.getAsBoolean());
15: System.out.println(b2.getAsBoolean());

------------------------------

Functional Interfaces for double, int, and long


Functional Interfaces	# Parameters		Return Type	Single Abstract Method
======================	====================	=============	=====================
DoubleSupplier		0			double		getAsDouble
IntSupplier					int		getAsInt
LongSupplier					long		getAsLong

DoubleConsumer		1(double)		void		accept
IntConsumer		1(int)	
LongConsumer		1(long)

DoublePredicate		1(double)		boolean		test
IntPredicate		1(int)
LongPredicate		1(long)

DoubleFunction<R>	1(double)		R		apply
IntFunction<R>		1(int)
LongFunction<R>		1(long)

DoubleUnaryOperator	1(double)		double		applyAsDouble
IntUnaryOperator	1(int)			int		applyAsInt
LongUnaryOperator	1(long)			long		applyAsLong

DoubleBinaryOperator	2(double, double)	double		applyAsDouble	
IntBinaryOperator	2(int, int)		int		applyAsInt
LongBinaryOperator	2(long,long)		long		applyAsLong



There are a few things to notice that are different between Table 4.1 and Table 4.9:

[] Generics are gone from some of the interfaces, since the type name tells us what primitive
type is involved. In other cases, such as IntFunction, only the return type generic is needed.	

[] The single abstract method is often, but not always, renamed to reflect the primitive
type involved.

[] BiConsumer, BiPredicate, and BiFunction are not in Table 4.9. The API designers
stuck to the most common operations. For primitives, the functions with two different
type parameters just aren’t used often.

TABELA 4.10...Verificar se necessario


===================================

Working with Advanced Stream
Pipeline Concepts


Linking Streams to the Underlying Data

25: List<String> cats = new ArrayList<>();
26: cats.add("Annie");
27: cats.add("Ripley");
28: Stream<String> stream = cats.stream();
29: cats.add("KC");
30: System.out.println(stream.count()); //3


Remember that streams are lazily evaluated. This
means that the stream isn’t actually created on line 28. An object is created that knows
where to look for the data when it is needed. On line 29, the List gets a new element. On
line 30, the stream pipeline actually runs.


Chaining Optionals

private static void threeDigit(Optional<Integer> optional) {
if (optional.isPresent()) { // outer if
Integer num = optional.get();
String string = "" + num;
if (string.length() == 3) // inner if
System.out.println(string);
} }

private static void threeDigit(Optional<Integer> optional) {
optional.map(n -> "" + n) // part 1
.filter(s -> s.length() == 3) // part 2
.ifPresent(System.out::println); // part 3
}

Now suppose that we wanted to get an Optional<Integer> representing the length of
the String contained in another Optional. Easy enough:
Optional<Integer> result = optional.map(String::length);


What if we had a helper method that did the logic of calculating something for us and it
had the signature static Optional<Integer> calculator(String s)? Using map doesn’t
work:

Optional<Integer> result = optional.map(ChainingOptionals::calculator); // DOES NOT COMPILE

The problem is that calculator returns Optional<Integer>. The map() method adds
another Optional, giving us Optional<Optional<Integer>>. Well, that’s no good. The
solution is to call flatMap() instead:

Optional<Integer> result = optional.flatMap(ChainingOptionals::calculator);

This one works because flatMap removes the unnecessary layer. In other words, it flattens
the result. Chaining calls to flatMap() is useful when you want to transform one
Optional type to another

------------------------------

Collecting Results


Table 4 .11 - verificar tabela 4.11


Collecting Using Basic Collectors

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
String result = ohMy.collect(Collectors.joining(", "));
System.out.println(result); // lions, tigers, bears

It is very important to pass the Collector to the collect method. It exists to help collect
elements. A Collector doesn’t do anything on its own.
Let’s try another one. What is the average length of the three animal names?

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Double result = ohMy.collect(Collectors.averagingInt(String::length));
System.out.println(result); // 5.333333333333333


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeSet<String> result = ohMy.filter(s -> s.startsWith("t")
.collect(Collectors.toCollection(TreeSet::new));
System.out.println(result); // [tigers]


-----------------------

Collecting into Maps

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<String, Integer> map = ohMy.collect(
Collectors.toMap(s -> s, String::length));
System.out.println(map); // {lions=5, bears=5, tigers=6}


Returning the same value passed into a lambda is a common operation, so Java provides
a method for it. You can rewrite s -> s as Function.identity(). It is not shorter and may
or may not be clearer, so use your judgment on whether to use it.

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, String> map = ohMy.collect(Collectors.toMap(String::length, k -> k)); // BAD

Running this gives an exception similar to the following:
Exception in thread "main" java.lang.IllegalStateException: Duplicate key lions
at java.util.stream.Collectors.lambda$throwingMerger$114(Collectors.java:133)
at java.util.stream.Collectors$$Lambda$3/1044036744.apply(Unknown Source)

What’s wrong? Two of the animal names are the same length.



Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, String> map = ohMy.collect(Collectors.toMap(
String::length, k -> k, (s1, s2) -> s1 + "," + s2));
System.out.println(map); // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class. java.util.HashMap


It so happens that the Map returned is a HashMap. This behavior is not guaranteed.
Suppose that we want to mandate that the code return a TreeMap instead. No problem. We
would just add a constructor reference as a parameter:

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, String> map = ohMy.collect(Collectors.toMap(
String::length, k -> k, (s1, s2) -> s1 + "," + s2, TreeMap::new));
System.out.println(map); // // {5=lions,bears, 6=tigers}
System.out.println(map.getClass()); // class. java.util.TreeMap

---------------------------

Collecting Using Grouping, Partitioning, and Mapping

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, List<String>> map = ohMy.collect(
Collectors.groupingBy(String::length));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Set<String>> map = ohMy.collect(
Collectors.groupingBy(String::length, Collectors.toSet()));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, Set<String>> map = ohMy.collect(
Collectors.groupingBy(String::length, TreeMap::new, Collectors.toSet()));
System.out.println(map); // {5=[lions, bears], 6=[tigers]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
TreeMap<Integer, List<String>> map = ohMy.collect(
Collectors.groupingBy(String::length, TreeMap::new, Collectors.toList()));
System.out.println(map);


Partitioning is a special case of grouping. With partitioning, there are only two possible
groups—true and false. Partitioning is like splitting a list into two parts.

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, List<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 5));
System.out.println(map); // {false=[tigers], true=[lions, bears]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, List<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 7));
System.out.println(map); // {false=[], true=[lions, tigers, bears]}


Notice that there are still two keys in the map—one for each boolean value. It so happens
that one of the values is an empty list, but it is still there. As with groupingBy(), we
can change the type of List to something else:

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Boolean, Set<String>> map = ohMy.collect(
Collectors.partitioningBy(s -> s.length() <= 7, Collectors.toSet()));
System.out.println(map);// {false=[], true=[lions, tigers, bears]}

Unlike groupingBy(), we cannot change the type of Map that gets returned.

Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Long> map = ohMy.collect(Collectors.groupingBy(
String::length, Collectors.counting()));
System.out.println(map); // {5=2, 6=1}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Optional<Character>> map = ohMy.collect(
Collectors.groupingBy(
String::length,
Collectors.mapping(s -> s.charAt(0),
Collectors.minBy(Comparator.naturalOrder()))));
System.out.println(map); // {5=Optional[b], 6=Optional[t]}


Stream<String> ohMy = Stream.of("lions", "tigers", "bears");
Map<Integer, Optional<Character>> map = ohMy.collect(
groupingBy(
String::length,
mapping(s -> s.charAt(0),
minBy(Comparator.naturalOrder()))));
System.out.println(map); // {5=Optional[b], 6=Optional[t]}




Cap5
LocalDate Contains just a date—no time and no time zone.
LocalTime Contains just a time—no date and no time zone
LocalDateTime Contains both a date and time but no time zone.
ZonedDateTime Contains a date, time, and time zone.


System.out.println(LocalDate.now());
System.out.println(LocalTime.now());
System.out.println(LocalDateTime.now());
System.out.println(ZonedDateTime.now());


2015–05–25
09:13:07.768
2015–05–25T09:13:07.768
2015–05–25T09:13:07.769–04:00[America/New_York]


Greenwich Mean Time(GMT) is a time zone in Europe that is used as time zone zero when
discussing offsets.
Coordinated Universal Time(UTC) uses the same time zone zero as GMT.

2015–06–20T07:50+02:00[Europe/Paris] // GMT 2015–06–20 5:50
2015–06–20T06:50+05:30[Asia/Kolkata] // GMT 2015–06–20 1:20

2015–06–20T07:50 GMT-04:00 // GMT 2015–06–20 11:50
2015–06–20T04:50 GMT-07:00 // GMT 2015–06–20 11:50

2015–06–20T07:50–07:00[US/Pacific]   = 2015–06–20T14:50 
2015–06–20T07:50+05:30[Asia/Kolkata] = 2015–06–20T2:20


public static LocalDate of(int year, int month, int dayOfMonth)
public static LocalDate of(int year, Month month, int dayOfMonth)

public static LocalTime of(int hour, int minute)
public static LocalTime of(int hour, int minute, int second)
public static LocalTime of(int hour, int minute, int second, int nanos)


public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, int month, int dayOfMonth, int hour, int minute, int second, int nanos)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second)
public static LocalDateTime of(int year, Month month, int dayOfMonth, int hour, int minute, int second, int nanos)
public static LocalDateTime of(LocalDate date, LocalTime time)


ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime zoned1 = ZonedDateTime.of(2015, 1, 20, 6, 15, 30, 200, zone);
ZonedDateTime zoned2 = ZonedDateTime.of(date1, time1, zone);
ZonedDateTime zoned3 = ZonedDateTime.of(dateTime1, zone);

public static ZonedDateTime of(int year, int month,int dayOfMonth, int hour, 
			       int minute, int second, int nanos, ZoneId zone)
public static ZonedDateTime of(LocalDate date, LocalTime time, ZoneId zone)
public static ZonedDateTime of(LocalDateTime dateTime, ZoneId zone)

Notice that there isn’t an option to pass in the Month enum. This seems like an oversight
from the API creators and something that will be fixed in future versions of Java.


ZoneId.getAvailableZoneIds().stream()
	.filter(z -> z.contains("US") || z.contains("America"))
	.sorted().forEach(System.out::println);


LocalDate.of(2015, Month.JANUARY, 32) // throws DateTimeException


12: LocalDate date = LocalDate.of(2014, Month.JANUARY, 20);
13: System.out.println(date); // 2014–01–20
14: date = date.plusDays(2);
15: System.out.println(date); // 2014–01–22
16: date = date.plusWeeks(1);
17: System.out.println(date); // 2014–01–29
18: date = date.plusMonths(1);
19: System.out.println(date); // 2014–02–28
20: date = date.plusYears(5);
21: System.out.println(date); // 2019–02–28

February 29 exists only in a leap year. Leap years are years that are a multiple
of 4 or 400 but not other multiples of 100. For example, 2000 and 2016
are leap years, but 2100 is not.


Period annually = Period.ofYears(1); // every 1 year
Period quarterly = Period.ofMonths(3); // every 3 months
Period everyThreeWeeks = Period.ofWeeks(3); // every 3 weeks
Period everyOtherDay = Period.ofDays(2); // every 2 days
Period everyYearAndAWeek = Period.of(1, 0, 7); // every year and 7 days


Period wrong = Period.ofYears(1).ofWeeks(1); // every week


System.out.println(Period.of(0, 20, 47));//P20M47D
System.out.println(Period.ofWeeks(3)); //P21D

--------------------------

Working with Durations
For Duration, you can specify the number of days, hours, minutes, seconds, or nanoseconds

Remember that a Period is output beginning with a P. Duration is output beginning with PT.

Duration daily = Duration.ofDays(1); // PT24H
Duration hourly = Duration.ofHours(1); // PT1H
Duration everyMinute = Duration.ofMinutes(1); // PT1M
Duration everyTenSeconds = Duration.ofSeconds(10); // PT10S
Duration everyMilli = Duration.ofMillis(1); // PT0.001S
Duration everyNano = Duration.ofNanos(1); // PT0.000000001S

Duration includes another more generic factory method. It takes a number and a
TemporalUnit. The idea is, say, something like “5 seconds.” However, TemporalUnit is an
interface. At the moment, there is only one implementation named ChronoUnit.
The previous example could be rewritten as this:

Duration daily = Duration.of(1, ChronoUnit.DAYS);
Duration hourly = Duration.of(1, ChronoUnit.HOURS);
Duration everyMinute = Duration.of(1, ChronoUnit.MINUTES);
Duration everyTenSeconds = Duration.of(10, ChronoUnit.SECONDS);
Duration everyMilli = Duration.of(1, ChronoUnit.MILLIS);
Duration everyNano = Duration.of(1, ChronoUnit.NANOS);

ChronoUnit also includes some convenient units such as ChronoUnit.HALF_DAYS to represent
12 hours.


LocalTime one = LocalTime.of(5, 15);
LocalTime two = LocalTime.of(6, 30);
LocalDate date = LocalDate.of(2016, 1, 20);
System.out.println(ChronoUnit.HOURS.between(one, two)); // 1
System.out.println(ChronoUnit.MINUTES.between(one, two)); // 75
System.out.println(ChronoUnit.MINUTES.between(one, date)); // DateTimeException


7: LocalDate date = LocalDate.of(2015, 1, 20);
8: LocalTime time = LocalTime.of(6, 15);
9: LocalDateTime dateTime = LocalDateTime.of(date, time);
10: Duration duration = Duration.ofHours(6);
11: System.out.println(dateTime.plus(duration)); // 2015–01–20T12:15
12: System.out.println(time.plus(duration)); // 12:15
13: System.out.println(date.plus(duration)); // UnsupportedTemporalException


7: LocalDate date = LocalDate.of(2015, 1, 20);
8: LocalTime time = LocalTime.of(6, 15);
9: LocalDateTime dateTime = LocalDateTime.of(date, time);
10: Duration duration = Duration.ofHours(23);
11: System.out.println(dateTime.plus(duration)); // 2015–01–21T05:15
12: System.out.println(time.plus(duration)); // 05:15          
13: System.out.println(date.plus(duration)); // UnsupportedTemporalException


LocalDate date = LocalDate.of(2015, 5, 25);
Period period = Period.ofDays(1);
Duration days = Duration.ofDays(1);
System.out.println(date.plus(period)); // 2015–05–26
System.out.println(date.plus(days)); // Unsupported unit: Seconds


			Can Use with Period? 	Can Use with Duration?
LocalDate 		Yes 			No
LocalDateTime 		Yes 			Yes
LocalTime 		No 			Yes
ZonedDateTime 		Yes 			Yes



---------------------------------


Working with Instants

Instant now = Instant.now();
// do something time consuming
Instant later = Instant.now();

Duration duration = Duration.between(now, later);
System.out.println(duration.toMillis());


LocalDate date = LocalDate.of(2015, 5, 25);
LocalTime time = LocalTime.of(11, 55, 00);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime zonedDateTime = ZonedDateTime.of(date, time, zone);
Instant instant = zonedDateTime.toInstant(); // 2015–05–25T15:55:00Z
System.out.println(zonedDateTime); // 2015–05–25T11:55–04:00[US/Eastern]
System.out.println(instant); // 2015–05–25T15:55:00Z

You cannot convert a LocalDateTime to an Instant. Remember that an Instant is a
point in time. A LocalDateTime does not contain a time zone, and it is therefore not universally
recognized around the world as the same moment in time.


If you have the number of seconds since 1970, you can also create an Instant that way:

Instant instant = Instant.ofEpochSecond(epochSeconds);
System.out.println(instant); // 2015–05–25T15:55:00Z



Instant nextDay = instant.plus(1, ChronoUnit.DAYS);
System.out.println(nextDay); // 2015–05–26T15:55:00Z
Instant nextHour = instant.plus(1, ChronoUnit.HOURS);
System.out.println(nextHour); // 2015–05–25T16:55:00Z
Instant nextWeek = instant.plus(1, ChronoUnit.WEEKS); // exception


Instant nextDay = instant.plus(1, ChronoUnit.DAYS);
System.out.println(nextDay); // 2015–05–26T15:55:00Z
Instant nextHour = instant.plus(1, ChronoUnit.HOURS);
System.out.println(nextHour); // 2015–05–25T16:55:00Z
Instant nextWeek = instant.plus(1, ChronoUnit.WEEKS); // exception

It’s weird that an Instant displays a year and month while preventing you from doing
math with those fields. Unfortunately, you need to memorize this fact.


------------------------------

Accounting for Daylight Savings Time

On March 13, 2016, we move our clocks forward an hour and jump from 2:00 a.m. to 3:00 a.m. 
This means that there is no 2:30 a.m. that day. If we wanted to know the time an hour later than 1:30, 
it would be 3:30.

LocalDate date = LocalDate.of(2016, Month.MARCH, 13);
LocalTime time = LocalTime.of(1, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2016–03–13T01:30–05:00[US/Eastern]
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2016–03–13T03:30–04:00[US/Eastern]

Notice that two things change in this example. The time jumps from 1:30 to 3:30. The
UTC offset also changes. Remember when we calculated GMT time by subtracting the time
zone from the time? You can see that we went from 6:30 GMT (1:30 minus -5:00) to 7:30
GMT (3:30 minus -4:00). This shows that the time really did change by one hour from
GMT’s point of view.


Similarly in November, an hour after the initial 1:30 is also 1:30 because at 2:00 a.m.
we repeat the hour.


LocalDate date = LocalDate.of(2016, Month.NOVEMBER, 6);
LocalTime time = LocalTime.of(1, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2016–11–06T01:30–04:00[US/Eastern] //5:30GMT
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2016–11–06T01:30–05:00[US/Eastern] //6:30GMT
dateTime = dateTime.plusHours(1);
System.out.println(dateTime); // 2016–11–06T02:30–05:00[US/Eastern] //7:30GMT



LocalDate date = LocalDate.of(2016, Month.MARCH, 13);
LocalTime time = LocalTime.of(2, 30);
ZoneId zone = ZoneId.of("US/Eastern");
ZonedDateTime dateTime = ZonedDateTime.of(date, time, zone);
System.out.println(dateTime); // 2016–03–13T03:30–04:00[US/Eastern]


-----------------------------

Reviewing the String class

4: String s1 = "bunny";
5: String s2 = "bunny";
6: String s3 = new String("bunny");
7: System.out.println(s1 == s2); // true
8: System.out.println(s1 == s3); // false
9: System.out.println(s1.equals(s3)); // true

10: String s4 = "1" + 2 + 3;
11: String s5 = 1 + 2 + "3";
12: System.out.println(s4); // 123
13: System.out.println(s5); // 33

14: String s = "abcde ";
15: System.out.println(s.trim().length()); // 5
16: System.out.println(s.charAt(4)); // e
17: System.out.println(s.indexOf('e')); // 4
18: System.out.println(s.indexOf("de")); // 3
19: System.out.println(s.substring(2, 4).toUpperCase()); // CD
20: System.out.println(s.replace('a', '1')); // 1bcde
21: System.out.println(s.contains("DE")); // false
22: System.out.println(s.startsWith("a")); // true


3: StringBuilder b = new StringBuilder();
4: b.append(12345).append('-');
5: System.out.println(b.length()); // 6
6: System.out.println(b.indexOf("-")); // 5
7: System.out.println(b.charAt(2)); // 3
8:
9: StringBuilder b2 = b.reverse();
10: System.out.println(b.toString()); // -54321
11: System.out.println(b == b2); // true


12: StringBuilder s = new StringBuilder("abcde");
13: s.insert(1, '-').delete(3, 4); //a-bcde -> a-bde   
14: System.out.println(s); //a-bde
15: System.out.println(s.substring(2, 4)); // bd


Characteristic 	 String 	StringBuilder 	StringBuffer
Immutable? 	 Yes 		No 		No
Pooled? 	 Yes 		No 		No
Thread-safe? 	 Yes 		No 		Yes
Can change size? No 		Yes 		Yes

------------------

Adding Internationalization and Localization

java.util.Locale

Locale locale = Locale.getDefault();
System.out.println(locale);

invalid Locales:
US // can have a language without a country, but not the reverse
enUS // missing underscore
US_en // the country and language are reversed
EN // language must be lowercase

The corrected versions are en and en_US.


There are three main ways of creating a Locale . 

First, the Locale class provides constants for some of the most commonly used locales:

System.out.println(Locale.GERMAN); // de
System.out.println(Locale.GERMANY); // de_DE


The other two main ways of creating a Locale are to use the constructors. 
You can pass just a language or both a language and country:

System.out.println(new Locale("fr")); // fr
System.out.println(new Locale("hi", "IN")); // hi_IN

================= NOT IN EXAM
Locale l1 = new Locale.Builder()
.setLanguage("en")
.setRegion("US")
.build();

Locale l2 = new Locale.Builder()
.setRegion("US")
.setLanguage("en")
.build();


Locale l2 = new Locale.Builder() // bad but legal
.setRegion("us")
.setLanguage("EN")
.build();

==================

System.out.println(Locale.getDefault()); // en_US
Locale locale = new Locale("fr");
Locale.setDefault(locale); // change the default
System.out.println(Locale.getDefault()); // fr


Locale us = new Locale("en", "US");
Locale france = new Locale("fr", "FR");
Locale englishCanada = new Locale("en", "CA");
Locale frenchCanada = new Locale("fr", "CA");



Zoo_en.properties
   hello=Hello
   open=The zoo is open.
Zoo_fr.properties
   hello=Bonjour
   open=Le zoo est ouvert


1: import java.util.*;
2: public class ZooOpen {
3:
4: public static void main(String[] args) {
5:    Locale us = new Locale("en", "US");
6:    Locale france = new Locale("fr", "FR");
8:    printProperties(us);
9:    System.out.println();
10:   printProperties(france);
11: }
12:
13: public static void printProperties(Locale locale) {
14:    ResourceBundle rb = ResourceBundle.getBundle("Zoo", locale);
15:    System.out.println(rb.getString("hello"));
16:    System.out.println(rb.getString("open"));
17: }
18: }


The output is as follows:
Hello
The zoo is open.

Bonjour
Le zoo est ouvert



Property File Format
animal=dolphin
animal:dolphin
animal dolphin


# one comment
! another comment
key = value\tafter tab
long = abcdefghijklm\
nopqrstuvwxyz

Printing out these two properties in a program gives us this:

value ? after tab
abcdefghijklmnopqrstuvwxyz



The ResourceBundle class provides a method to get a set of all keys:

Locale us = new Locale("en", "US");
ResourceBundle rb = ResourceBundle.getBundle("Zoo", us);
Set<String> keys = rb.keySet();
keys.stream()
    .map(k -> k + " " + rb.getString(k))
    .forEach(System.out::println);


Properties props = new Properties();
rb.keySet()
  .stream()
  .forEach(k -> props.put(k, rb.getString(k)));


System.out.println(props.getProperty("notReallyAProperty"));
System.out.println(props.getProperty("notReallyAProperty", "123"));

The first line prints null, since that property doesn’t exist. The second prints 123, since
the property wasn’t found. If a key were passed that actually existed, both would have
returned it.


Key Found? 			Yes 	No
==========================	======	======
getProperty("key") 		Value 	null
getProperty("key", "default") 	Value 	"default"


To implement a resource bundle in Java, you create a class with the same name that you
would use for a property file. Only the extension is different. Since we have a Java object,
the file must be a .java file rather than a .properties file. For example, the following class
is equivalent to the property file that you saw in the last section:


1: import java.util.*;
2: public class Zoo_en extends ListResourceBundle {
3: protected Object[][] getContents() {
4: return new Object[][] {
5: { "hello", "Hello" },
6: { "open", "The zoo is open" } };
7: } }


There are two main advantages of using a Java class instead of a property file for a
resource bundle:
[] You can use a value type that is not a String.
[] You can create the values of the properties at runtime.


1: package resourcebundles;
2: import java.util.*;
3: public class Tax_en_US extends ListResourceBundle {
4: protected Object[][] getContents() {
5:    return new Object[][] { { "tax", new UsTaxCode() } };
6: }
7: public static void main(String[] args) {
8:    ResourceBundle rb = ResourceBundle.getBundle(
9:                        "resourcebundles.Tax", Locale.US);
10: System.out.println(rb.getObject("tax"));
11: }}

Line 3 extends the ListResourceBundle so that we can define a resource bundle. This
time, the class name specifies both the language code and country code. Lines 4–6 show
the method to declare the key/value pairs. This time, the value is not a String. Lines 8–9
show that a resource bundle can be in a package. We just specify the name of the package
before the name of the class. Line 10 shows how to retrieve a non-String resource bundle.


ResourceBundle.getBundle("name");
ResourceBundle.getBundle("name", locale);


The first one uses the default locale. You are likely to use this one in programs that you
write. The exam either tells you what to assume as the default locale or uses the second
approach.


Table 5.7 Picking a resource bundle for French in France with default locale US English

Step 		Looks for File 			Reason
1 		Zoo_fr_FR.java 			The requested locale
2 		Zoo_fr_FR.properties 		The requested locale
3 		Zoo_fr.java 			The language we requested with no country
4 		Zoo_fr.properties		The language we requested with no country
5 		Zoo_en_US.java 			The default locale
6 		Zoo_en_US.properties 		The default locale
7 		Zoo_en.java 			The default language with no country 
8 		Zoo_en.properties 		The default language with no country
9		Zoo.java 			No locale at all—the default bundle
10 		Zoo.properties 			No locale at all—the default bundle
11		If still not found, throw
		MissingResourceException.



How many files do you think Java would need to look for to find the resource bundle
with the code?

Locale.setDefault(new Locale("hi"));
ResourceBundle rb = ResourceBundle.getBundle("Zoo", new Locale("en"));


The answer is six. They are listed here:
1. Zoo_hi.java
2. Zoo_hi.properties
3. Zoo_en.java
4. Zoo_en.properties
5. Zoo.java
6. Zoo.properties

------------------------


Zoo.properties
   name=Vancouver Zoo

Zoo_en.properties
   hello=Hello
   open=is open

Zoo_en_CA.properties
   visitor=Canada visitor

Zoo_fr.properties
   hello=Bonjour  
   open=est ouvert

Zoo_fr_CA.properties
   visitor=Canada visiteur


(a default locale of French Canada)

2: Locale locale = new Locale("en", "CA");
3: ResourceBundle rb = ResourceBundle.getBundle("Zoo", locale); 
4: System.out.print(rb.getString("hello")); //Zoo_en.properties Hello
5: System.out.print(". ");
6: System.out.print(rb.getString("name")); //Zoo.properties Vancouver Zoo
7: System.out.print(" ");
8: System.out.print(rb.getString("open")); //Zoo_en.properties  is open
9: System.out.print(" ");
10: System.out.print(rb.getString("visitor")); //Zoo_en_CA.properties Canada visitor


 
-----------------

Formatting Numbers


1: import java.text.*;
2: import java.util.*;
3:
4: public class FormatNumbers {
5: public static void main(String[] args) {
6: int attendeesPerYear = 3_200_000;
7: int attendeesPerMonth = attendeesPerYear / 12;
8: NumberFormat us = NumberFormat.getInstance(Locale.US);
9: System.out.println(us.format(attendeesPerMonth));
10: NumberFormat g = NumberFormat.getInstance(Locale.GERMANY);
11: System.out.println(g.format(attendeesPerMonth));
12: NumberFormat ca = NumberFormat.getInstance(Locale.CANADA_FRENCH);
13: System.out.println(ca.format(attendeesPerMonth));
14: } }
The output looks like this:
266,666
266.666
266 666


double price = 48;
NumberFormat us = NumberFormat.getCurrencyInstance();
System.out.println(us.format(price));
When run with the default locale of en_US , the output is $48.00. Java automatically formats
with two decimals and adds the dollar sign. This is convenient even if you don’t need
to localize your program!


Parsing

The parse methods for the different types of formats throw the checked exception
ParseException if they fail to parse.
You can assume that exceptions are properly handled.
If you see parsing logic inside a method, make sure that ParseException or Exception is
handled or declared.

NumberFormat en = NumberFormat.getInstance(Locale.US);
NumberFormat fr = NumberFormat.getInstance(Locale.FRANCE);
String s = "40.45";
System.out.println(en.parse(s)); // 40.45
System.out.println(fr.parse(s)); // 40

In the United States, a dot is part of a number and the number is parsed how you might
expect. France does not use a decimal point to separate numbers. Java parses it as a formatting
character, and it stops looking at the rest of the number. The lesson is to make sure
that you parse using the right locale!



NumberFormat nf = NumberFormat.getInstance();
String one = "456abc";
String two = "-2.5165x10";
String three = "x85.3";
System.out.println(nf.parse(one)); // 456
System.out.println(nf.parse(two)); // -2.5165
System.out.println(nf.parse(three));// throws ParseException

The first two lines parse correctly. There happen to be extra characters after the number,
but that’s OK. The third parsing fails because there are no numbers at the beginning of
the String. Java instead throws a java.text.ParseException.

String amt = "$92,807.99";
NumberFormat cf = NumberFormat.getCurrencyInstance();
double value = (Double) cf.parse(amt);
System.out.println(value); // 92807.99 

The currency string "$92,807.99" contains a dollar sign and a comma. The parse
method strips out the characters and converts the value to a number. The return value of
parse is a Number object. Number is the parent class of all the java.lang wrapper classes, so
the return value can be cast to its appropriate data type. The Number is cast to a Double and
then automatically unboxed into a double.


Formatting Dates and Times

LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
System.out.println(date.getDayOfWeek()); // MONDAY
System.out.println(date.getMonth()); // JANUARY
System.out.println(date.getYear()); // 2020
System.out.println(date.getDayOfYear()); // 20


LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);
System.out.println(date.format(DateTimeFormatter.ISO_LOCAL_DATE));
System.out.println(time.format(DateTimeFormatter.ISO_LOCAL_TIME));
System.out.println(dateTime.format(DateTimeFormatter.ISO_LOCAL_DATE_TIME));

2020–01–20
11:12:34
2020–01–20T11:12:34


DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
System.out.println(shortDateTime.format(dateTime)); // 1/20/20
System.out.println(shortDateTime.format(date)); // 1/20/20
System.out.println(shortDateTime.format(time)); // UnsupportedTemporalTypeException

The last line throws an exception because a time cannot be formatted as a date


The following statements print exactly the same thing as the previous code:

DateTimeFormatter shortDateTime = DateTimeFormatter.ofLocalizedDate(FormatStyle.SHORT);
System.out.println(dateTime.format(shortDateTime));
System.out.println(date.format(shortDateTime));
System.out.println(time.format(shortDateTime));



Table 5.10 - vizualizar --


LocalDate date = LocalDate.of(2020, Month.JANUARY, 20);
LocalTime time = LocalTime.of(11, 12, 34);
LocalDateTime dateTime = LocalDateTime.of(date, time);
DateTimeFormatter shortF = DateTimeFormatter
.ofLocalizedDateTime(FormatStyle.SHORT);
DateTimeFormatter mediumF = DateTimeFormatter
.ofLocalizedDateTime(FormatStyle.MEDIUM);
System.out.println(shortF.format(dateTime)); // 1/20/20 11:12 AM
System.out.println(mediumF.format(dateTime)); // Jan 20, 2020 11:12:34 AM


DateTimeFormatter f = DateTimeFormatter.ofPattern("MMMM dd, yyyy, hh:mm");
System.out.println(dateTime.format(f)); // January 20, 2020, 11:12

MMMM M represents the month. The more Ms you have, the more verbose the Java output. For
example, M outputs 1, MM outputs 01, MMM outputs Jan, and MMMM outputs January.
dd d represents the day in the month. As with month, the more ds you have, the more verbose
the Java output. dd means to include the leading zero for a single-digit day.
, Use , if you want to output a comma (this also appears after the year).
yyyy y represents the year. yy outputs a two-digit year and yyyy outputs a four-digit year.
hh h represents the hour. Use hh to include the leading zero if you’re outputting a single-digit hour.
: Use : if you want to output a colon.
mm m represents the minute omitting the leading zero if present. mm is more common and
represents the minutes using two digits


DateTimeFormatter f = DateTimeFormatter.ofPattern("MM dd yyyy");
LocalDate date = LocalDate.parse("01 02 2015", f);
LocalTime time = LocalTime.parse("11:22");
System.out.println(date); // 2015–01–02
System.out.println(time); // 11:22


Cap 6 - Exceptions and Assertions

